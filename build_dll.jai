#scope_file
#import "Compiler";
#import "Basic";
#import "Process";
#import "File";

#import "Metaprogram_Plugins";

OUT_LIB_NAME :: "pimp";
OUTPUT_EXECUTABLE_NAME_WITH_EXYENSION :: "pimp.dll";
OUTPUT_BUILD_DIR :: "./windows";
FILE_ENTRY_POINT :: "./module.jai";

#run {

    set_build_options_dc(.{do_output = false});
    current_w := get_current_workspace();

    {
    w := compiler_create_workspace("Physics dynamically linkable library");
    options := get_build_options(w);
        copy_commonly_propagated_fields(get_build_options(), *options); //we make the new workspace inherit the commands from current_w
        // set_optimization(*options, .OPTIMIZED);
        // set_optimization(*options, .VERY_OPTIMIZED); //for vectorization
        options.output_type            = .DYNAMIC_LIBRARY;
        options.output_executable_name = OUT_LIB_NAME;
        options.output_path            = OUTPUT_BUILD_DIR;
        //
        // Maximize debug info:
        //
        //this is useful for stepping inside #asm blocks
        // if options.backend == .X64 && false
        // {
        //     options.shorten_filenames_in_error_messages = true;
        //     options.use_natvis_compatible_types = true;
        //     options.use_visual_studio_message_format = true;
        //     options.enable_bytecode_inliner = false;
        //     options.enable_bytecode_deduplication = false;
        //     options.interactive_bytecode_debugger = true;
        //     options.debug_for_expansions = true;
        //     // maybe comment out the following
        //     options.emit_debug_info = .CODEVIEW;
        // }

        //because -import_dir doesnt work on cmd line because workspaces.
        modules_paths: [..]string;
        array_add(*modules_paths, "C:/_paths/my_modules/");
        if modules_paths {
            array_add(*modules_paths, ..options.import_path);
            options.import_path = modules_paths;
        }
    set_build_options(options, w);

    compiler_begin_intercept(w);
        add_build_file(FILE_ENTRY_POINT,w); //compilin starts here on another thread process
        message_loop(w);
    compiler_end_intercept(w);
    }


}

should_flatten_out:: (decl: *Code_Declaration) -> bool {
    //flatttening out of overloads not implemented yet.
    for decl.notes {
        if it.text == "dll_export"  return true;
        if it.text == "dll_flatten"   return true;
    }

    return false;
}

should_flatten_out_overload :: (header: *Code_Procedure_Header) -> bool {
//flatttening out of overloads not implemented yet.
    for header.notes {
        if it.text == "dll_export"  return true;
        if it.text == "dll_flatten"   return true;
    }

    return false;
}

#import "Hash_Table";
#import "Program_Print";
#import "File";

///
/// I built this iterating a lot so its messy, I dont find value in reducint the entropy of this code because I prefer to spent time solving other more important problems for now. Most comments dont make sense anymore and I did not deleted them.
///
structs_in_existence: Table(string, Code_Declaration);
structs_in_existence_to_print: Table(string, Code_Declaration);
// structs_in_existence_childen: Table(string, void);
structs_childrens: Table(string, Table(string, void));
current_table: *Table(string, void);
current_key: string;
structs_to_print: Table(string, void);


print_block :: (block: *Code_Block) -> string{
    builder: String_Builder;
    print_block(*builder, block);
    return builder_to_string(*builder);
}

message_loop :: (w: Workspace) {
    sb: String_Builder;
    sb_procs: String_Builder;
    procedure_names: [..]string;
    procedure_is_modifying_context: [..]bool;
    print_to_builder(*sb, "//File autogenerated by build_dll.jai ----\n");
    // print_to_builder(*sb_procs, "//File autogenerated by build_dll.jai ----\n");
    // print_to_builder(*sb_procs, "\n//\n// PROCEDURES\n//\n");
    while true {
        message := compiler_wait_for_message();
        if message.workspace != w then continue;
        // We ignore most message types. We mainly want to know about code that has been typechecked,
        // so that we can look for the data structures we care about; or, when all the code is done
        // being typechecked, we want to generate our new code.
        if message.kind == {
          case .TYPECHECKED;
            tc := cast(*Message_Typechecked) message;
            {
                for tc.declarations {
                    if it.expression.kind == .DECLARATION {
                        decl := cast(*Code_Declaration) it.expression;
                        load := decl.enclosing_load;

                        import := load.enclosing_import;
                        assert(import != null);
                        if import && decl.name
                        {
                            //we add structs with @dll_export notes too.
                            if should_flatten_out(decl) {
                                //we excude procedures because we add them in other part of the code
                                if decl.expression.kind != .PROCEDURE_HEADER {
                                    table_set(*structs_in_existence, decl.name, decl.*); //just in case
                                    find_or_add(*structs_to_print, decl.name);
                                }
                            }
                            name := decl.name;
                            //ignore the followings:
                            Ins := decl.type_inst;
                            Exp := decl.expression;
                            if import.module_name == {
                                case "realtime.jai";#through;
                                case "collision_related/convex_hull.jai";

                                table_set(*structs_in_existence, decl.name, decl.*);
                                current_table = find_or_add(*structs_childrens, decl.name);
                                current_key = decl.name;
                                // log("current_key %", current_key);
                                find_actual_name_declaration(decl);

                            }
                         if import.module_type ==
                            {
                              case .PRELOAD;
                              case .RUNTIME_SUPPORT;
                              case .MAIN_PROGRAM;
                                table_set(*structs_in_existence, decl.name, decl.*);
                                current_table = find_or_add(*structs_childrens, decl.name);
                                current_key = decl.name;
                                // log("current_key %", current_key);
                                find_actual_name_declaration(decl);
                              case .FILE;
                              case;
                                compiler_report(tprint("Ugh! Unhandled import.module_type %.\n", import.module_type));
                            }
                        }

                    }
                }

                for tc.procedure_headers {
                    header := it.expression;
                    // check_print_calls(it);
                    if header.procedure_flags & .POLYMORPHIC continue;  // Do nothing with polymorphic procedures.
                    if header.procedure_flags & .MACRO       continue;  // Do nothing with macro headers.
                    if should_flatten_out_overload(header) {
                        {


                            }
                            // print_to_builder(*sb, "#program_export\n");
                            print_to_builder(*sb, "% : #type ", header.name);
                            array_add(*procedure_names, header.name);
                            array_add(*procedure_is_modifying_context, false);

                            //
                            // Print procedure arguments
                            //
                            {
                                append(*sb, "(");
                                previously_printed: bool;
                                for header.arguments
                                {
                                 // print_to_builder(*sb, "name: %\n", it.name);
                                 // print_to_builder(*sb, "kind: %\n", it.kind);
                                    if it.kind == it.kind.DECLARATION
                                    {
                                        decl := cast(*Code_Declaration) it;
                                        if decl.name
                                        {
                                            // log("%",decl.name);
                                            Ins := decl.type_inst;
                                            if Ins
                                            {
                                                found_type_name := find_type_name_single(Ins);
                                                // append(*sb, found_type_name);
                                                find_or_add(*structs_to_print, found_type_name);
                                            }

                                        }

                                        if previously_printed append(*sb, ", ");
                                        previously_printed = print_declaration(*sb, decl);
                                    }

                                }
                                append(*sb, ")");
                            }
                            //
                            // Print procedure return values
                            //
                            {
                                append(*sb, " -> ");
                                previously_printed: bool;
                                found_at_least_one : bool;
                                for header.returns
                                {
                                 // print_to_builder(*sb, "name: %\n", it.name);
                                 // print_to_builder(*sb, "kind: %\n", it.kind);
                                  if it.kind == it.kind.DECLARATION
                                  {
                                    decl := cast(*Code_Declaration) it;
                                    // if decl.name
                                        {
                                            // find_or_add(*structs_to_print, decl.name);

                                            // log("eader.return %",decl.name);
                                            // log("eader.return %",decl.name);
                                            // log("eader.return %",decl.name);
                                            // log("eader.return %",decl.name);
                                            Ins := decl.type_inst;
                                            if Ins
                                            {
                                                found_type_name := find_type_name_single(Ins);
                                                // append(*sb, found_type_name);
                                                if found_type_name {
                                                    // log("found_type_name %",found_type_name);
                                                    find_or_add(*structs_to_print, found_type_name);
                                                }
                                            }

                                        }

                                    if previously_printed append(*sb, ", ");
                                    previously_printed = print_declaration(*sb, decl);
                                    found_at_least_one |= previously_printed;
                                    // if printed append(*sb, ", ");
                                    }

                                }
                                if !found_at_least_one append(*sb, "void");
                                print_to_builder(*sb, ";// #foreign %;\n", OUT_LIB_NAME);
                            }
                    }

                    // if CHECK_BINDINGS {
                    //     success := verify_elsewhere_binding(header, build_options.os_target);
                    //     if !success {
                    //         compiler_set_workspace_status(.FAILED, message.workspace);
                    //     }
                    // }
                }
            }
            // for typechecked.structs  note_struct(it.expression);

          case .PHASE;
            phase := cast(*Message_Phase) message;
            if phase.phase == .TYPECHECKED_ALL_WE_CAN {
                // if !generated_code {
                    // generate_code(message.workspace);
                    // generated_code = true;
                // }
            }

          case .COMPLETE;
            break;
        }
    }
    print_to_builder(*sb, "\n//\n// STRUCTS\n//\n");

    for _, key: structs_to_print {
        // log("kkkkey %", key);
        parent_decl := table_find_pointer(*structs_in_existence, key);
        // log("foundasdasdasame %", key);
        //we check that it exists first
        if !parent_decl {
            // log("not found % %, if from external modue its ok tho", key, parent_decl);
            continue;
        }
        //we pull over the corresponding table with childrens of that struct
        tableptr := table_find_pointer(*structs_childrens, key);
        table_set(*structs_in_existence_to_print, key, parent_decl.*);
        if !tableptr  {
            log("not found % ", key);
            continue;
        }

        //
        // We mege the tables
        //
        //NOTE: I got stack overflow! so I reimplemented this in a non recursive way. extra note: Even tho you "unroll" the recursive function, waht you are actually doing when you do that is that you replace the stack memory with your own memory. :tagTeadthisCOmment
        // recursive_merge :: (table_ptr: *Table(string, void))
        // {


        //     for _, key2:  table_ptr {
        //         // log("% tableptr %",key,key2);
        //         child_decl := table_find_pointer(*structs_in_existence, key2);
        //         if child_decl {

        //             table_set(*structs_in_existence_to_print, key2, child_decl.*);
        //             table_ptr_next := table_find_pointer(*structs_childrens, key2);
        //             if table_ptr_next recursive_merge(table_ptr_next);
        //         };
        //         // else log("% WHAT %",key, key2);
        //         // find_or_add(*structs_in_existence_childen, key2);
        //     }
        // }

        // recursive_merge(tableptr);

    }

    //this repalces the stack recursive with a heap recursive, read comment :tagTeadthisCOmment
    merge_structs_iterative();

    //
    // We print the structs
    //
    for decl, key: structs_in_existence_to_print {
        // log("structs_in_existence_to_print %",key);
        printed := print_declaration(*sb, *decl);

        if printed then append(*sb, ";\n\n");

    }

    {
    append(*sb, "\nSTUD_PROC_POINTERS:= **void.[\n");
    for procedure_names {
        print_to_builder(*sb, "cast(*void)(*%),\n", it);
    }
    append(*sb, "];\n\n");
    append(*sb, "STUD_PROC_LIST :: string.[\n");
    for procedure_names {
        print_to_builder(*sb, "\"%\",\n", it);
    }
    print_to_builder(*sb, "];\n");


    }
    assert(write_entire_file("./generated_generated.jai", *sb)); //cant figure out a good name for that file so its generated_generated for now
}

merge_structs_iterative :: ()
{
    //TODO: make this procedure code readable
    stack: [..]string;
    visited: Table(string, void);

    for _, root_key: structs_to_print {
        parent_decl_ptr := table_find_pointer(*structs_in_existence, root_key);
        if (!parent_decl_ptr) {
            // log("not found % %, if from external module its ok tho", root_key, parent_decl_ptr);
            continue;
        }
        table_set(*structs_in_existence_to_print, root_key, parent_decl_ptr.*);

        child_table := table_find_pointer(*structs_childrens, root_key);
        if (!child_table) continue;

        table_reset(*visited);
        array_reset(*stack );

        for _, child_key: child_table {
            if (!table_find_pointer(*visited, child_key)) {
                array_add(*stack, child_key);
                find_or_add(*visited, child_key);
            }
        }


        while stack.count > 0 {
            last_index := stack.count - 1;
            key := stack[last_index];
            popped := pop(*stack);

            child_decl_ptr := table_find_pointer(*structs_in_existence, key);
            if (child_decl_ptr) {
                table_set(*structs_in_existence_to_print, key, child_decl_ptr.*);
            }

            next_child_table := table_find_pointer(*structs_childrens, key);
            if (!next_child_table) continue;

            for _, sub_key: next_child_table {
                if (!table_find_pointer(*visited, sub_key)) {
                    array_add(*stack, sub_key);
                    find_or_add(*visited, sub_key );
                }
            }
        }
    }

    table_reset(*visited);
}



find_actual_name_declaration :: (decl: *Code_Declaration) {
    // if
    Ins := decl.type_inst;
    Exp := decl.expression;
    if Ins
    {
        find_actual_name_type_inst(Ins);
    }
    if Exp {
        find_actual_name_expression(Exp);
    }
}


find_actual_name_expression :: (expression: *Code_Node) {
if expression.kind ==
    {
        case .IDENT;
            ident := cast(*Code_Ident) expression;
            // log("A-> %", ident.name);
            // find_or_add(*structs_in_existence_childen, ident.name);
            find_or_add(current_table, ident.name);
            // log("1\t %:adding... %",current_key, ident.name);
        case .DECLARATION;
            decl := cast(*Code_Declaration) expression;
            // log("B-> %", decl.name);
            // log("MM %",decl.name);
            // log("MM %",decl.name);
            // find_or_add(*structs_in_existence_childen, decl.name);
            // find_or_add(current_table, decl.name);
            // log("2\t %:adding... %",current_key, decl.name);
            find_actual_name_declaration(decl);
        case .TYPE_INSTANTIATION;
            inst := cast(*Code_Type_Instantiation) expression;
            // log("B-> %", inst.name);
            find_actual_name_type_inst(inst);
            // {
            //     if inst.type_valued_expression
            //     {
            //       found_type_name := find_actual_expresion_type_name(inst);
            //       // if found_type_name.count != 0
            //       //   log("C-> %", found_type_name);
            //       //   else
            //         find_actual_expression_name(inst);
            //       // find_or_add(*structs_in_existence_childen, decl.name);
            //     }
            //     // if inst.expression {
            //     //     find_actual_expression_name(inst.expression);
            //     // }
            // }
        // return print_declaration(builder, decl);
        case .BLOCK;
            c := cast(*Code_Block) expression;
            str := print_block(c);
            // log("BLOCK\t %:adding... %",current_key, str);
        case .STRUCT;
            c := cast(*Code_Struct) expression;
            // find_or_add(*structs_in_existence_childen, c.defined_type.name);
            find_or_add(current_table, c.defined_type.name);
            // log("3\t %:adding... %",current_key, c.defined_type.name);
            if current_key == "RigidBody" {vptr := table_find_pointer(*structs_childrens, "RigidBody"); if vptr log("% key %",current_table, vptr.*);};
            if c.block {
            for c.block.statements {
                    // if it.node_flags & .CREATED_BY_DESUGARING continue;

                    // if it.node_flags & .STATEMENT_IS_DEFERRED {
                    //     append(builder, "defer ");
                    // }

                    // if do_braces  indent(builder);
                    find_actual_name_expression(it);
                    // if do_braces || !skip_final_semicolon_if_not_braced || it_index != block.statements.count - 1 { // Skip the trailing semicolon for non-braced blocks, if requested
                    //     if printed maybe_do_semicolon(builder, it);
                    // }
                }
                // str := print_block(c.block);
                // log("-----%\n\nSTRUCT\t % ",current_key, str);
                // log("-----\t % %",current_key, str);
            }
        case .ENUM;
            c := cast(*Code_Enum) expression;
            // find_or_add(*structs_in_existence_childen, c.external_type.name);
            // log("MM %",c.external_type.name);
            find_or_add(current_table, c.external_type.name);
            // log("4\t %:adding... %",current_key, c.external_type.name);
            if c.internal_type_inst find_actual_name_type_inst(c.internal_type_inst);


        case .USING;
            u := cast(*Code_Using) expression;

            if u.filter_type == {
                case .NONE;
                    // append(builder, "using ");
                case .ONLY;
                    // append(builder, "using,only(");
                    // print_expression(builder, u.filter_expression);
                    // append(builder, ") ");
                case .EXCEPT;
                    // append(builder, "using,except(");
                    // print_expression(builder, u.filter_expression);
                    // append(builder, ") ");
                case .MAP;
                    // append(builder, "using,map(");
                    // print_expression(builder, u.filter_expression);
                    // append(builder, ") ");
            }

            find_actual_name_expression(u.expression);


         case .TYPE_DEFINITION;
            cd := cast(*Code_Type_Definition) expression;
            // log("E-> %", cd.*);
            // print_type_to_builder(builder, cd.info);
    }
}

find_actual_name_type_inst :: (inst: *Code_Type_Instantiation) {
        if inst.inst_flags & .TYPE_DIRECTIVE
        {
            // print_to_builder(builder, "#type");
            if inst.inst_flags & .TYPE_DIRECTIVE_DISTINCT
            {
            //     print_to_builder(builder, ",distinct");
            }
            if inst.inst_flags & .TYPE_DIRECTIVE_ISA
            {
            //     print_to_builder(builder, ",isa");
            }

            // print_to_builder(builder, " ");
            if inst.type_directive_target find_actual_name_type_inst(inst.type_directive_target);
            return ;
        }

    if inst.pointer_to {
        // append(builder, "*");
        find_actual_name_type_inst(inst.pointer_to);
        return ;
    }

    if inst.array_element_type {
        if inst.inst_flags & .VARARGS {
            // append(builder, ".. ");
        } else if inst.inst_flags & .RESIZABLE {
            // append(builder, "[..] ");
        } else if inst.array_dimension {
            // append(builder, "[");
            find_actual_name_expression(inst.array_dimension);
            // append(builder, "] ");
        } else {
            // append(builder, "[] ");
        }

        find_actual_name_type_inst(inst.array_element_type);
        return ;
    }

/*
    if inst.defines_polymorph_type_variable {
        append(builder, "$");  "}$"; // @Sigh; emacs formatting is crazy...
        append(builder, inst.defines_polymorph_type_variable.name);
        return;
    }
*/

    if inst.type_valued_expression {
        find_actual_name_expression(inst.type_valued_expression);

        if inst.must_implement {
            // append(builder, "/");
            // if inst.inst_flags & .INTERFACE  append(builder, "interface ");
            find_actual_name_expression(inst.must_implement);
        }
    } else {
        log_error("**************************** @Incomplete: Don't know how to print type instantiation at %:%. It looks like: %\n", get_filename(inst), inst.l0, inst.*);
        // append(builder, "/* @Incomplete: Don't know how to print this type instantiation. */");
    }

    return ;

}

//OLD, was missing recursivity, but I think I did not needed recursivity... and this as ok....
find_type_name_single :: (root: *Code_Type_Instantiation) -> found_type_name: string {

    next_is_pointer := root.pointer_to;
    next_is_arr := root.array_element_type;
    found_type := root.type_valued_expression;

    while (next_is_pointer != null || next_is_arr != null) {
        //traverse arr type
        if next_is_arr {
            if next_is_arr.type_valued_expression {
                found_type = next_is_arr.type_valued_expression;
                break;
            }

            if next_is_arr.array_element_type
            {
                next_is_arr=next_is_arr.array_element_type;
                next_is_pointer=null;
                continue;
            }
            if next_is_arr.pointer_to
            {
                next_is_pointer=next_is_arr.pointer_to;
                next_is_arr=null;
                continue;
            }
        }
        //traverse ptr type
        if next_is_pointer {
            if next_is_pointer.type_valued_expression {
                found_type = next_is_pointer.type_valued_expression;
                break;
            }
            if next_is_pointer.array_element_type
            {
                next_is_arr=next_is_arr.array_element_type;
                next_is_pointer=null;
                continue;
            }
            if next_is_pointer.pointer_to
            {
                next_is_pointer=next_is_arr.pointer_to;
                next_is_arr=null;
                continue;
            }
        }
    }
    if found_type == null then return "";
    // log(" kind der %, %", found_type.type.type, found_type.kind);
    if !(found_type.kind == .IDENT) {
        if root.type_valued_expression.kind == .IDENT {
            ident := cast(*Code_Ident) root.type_valued_expression;
            return ident.name;
        }
        return "";
      }
    ident := cast(*Code_Ident) found_type;
    // if ident.flags & .DEFINES_POLYMORPH_VARIABLE  append(*sb, "$"/* "$*/); // This confuses emacs, hence the weird comment.
    // if ident.flags & .HAS_SCOPE_MODIFIER  append(*sb, "`");
    // c := ifx ident.name then ident.name[0];
    // if !is_alpha(c) && (c != #char "_") append(*sb, "operator ");

    return ident.name;

}

check_print_calls :: (tc: Typechecked) {
    using Code_Node.Kind;

    //
    // @Incomplete: We are currently assuming the varargs is the last argument,
    // but since February 2018 this is no longer necessarily true, so
    // we will want to update this checking.  -jblow, 6 February 2018
    //
    for tc.subexpressions
    {
        if it.kind != PROCEDURE_CALL  continue;

        call := cast(*Code_Procedure_Call) it;
        expression := call.procedure_expression;
        while expression.kind == .BINARY_OPERATOR
        {
            binary_op := cast(*Code_Binary_Operator) expression;
            expression = binary_op.right;
        }
        if expression.kind != .IDENT     continue;

        ident := cast(*Code_Ident) expression;
        resolved: *Code_Declaration;
        if call.overloads
        {
            resolved = call.overloads.*[0];
        } else {
            resolved = ident.resolved_declaration;
        }
        if !resolved continue;
        if !resolved.expression continue;
        if resolved.expression.kind != .PROCEDURE_HEADER continue;
        header := cast(*Code_Procedure_Header) resolved.expression;

        log("heade2r %", header);
        if should_flatten_out_overload(header)
        {
            log("header %", header);
            log("header %", header);
            log("header %", header);
            log("header %", header);
            log("header %", header);
        }
    }

}

