# WARNING around 30% to 50% of this code was generated by AI.
# for blender 4.3.something
# how to use? jump to this tag with grep -> :tagLastLieneUsageReplacemanually
import bpy
import mathutils
from typing import List, Tuple

def _read_tokens_from_file(path: str):
    with open(path, 'r', encoding='utf-8') as f:
        for raw in f:
            line = raw.strip()
            if not line:
                continue
            for tok in line.split():
                yield tok
    yield None

def _read_line_chunks(f):
    with open(f, 'r', encoding='utf-8') as fh:
        for line in fh:
            s = line.strip()
            if s:
                yield s
    return

def import_skinned_mesh(filepath: str, object_name: str = None):
    def next_line(it):
        for ln in it:
            s = ln.strip()
            if s != "":
                return s
        return None

    with open(filepath, 'r', encoding='utf-8') as fh:
        lines_iter = iter(fh)

        # skip header version
        hdr = next_line(lines_iter)
        if hdr is None:
            raise Exception("Empty mesh file")

        # read header fields until 'joints:'
        joint_count = vertex_count = triangle_count = 0
        while True:
            ln = next_line(lines_iter)
            if ln is None:
                raise Exception("Unexpected EOF while reading header")
            if ln.startswith("joint_count"):
                joint_count = int(ln.split()[1])
            elif ln.startswith("vertex_count"):
                vertex_count = int(ln.split()[1])
            elif ln.startswith("triangle_count"):
                triangle_count = int(ln.split()[1])
            elif ln == "joints:":
                break

        # read joints, hope for the best
        joints = []
        parent_indices = []
        for j in range(joint_count):
            name = next_line(lines_iter)
            if name is None:
                raise Exception("Unexpected EOF while reading joint name")
            # read four matrix rows (each must contain 4 floats)
            rows = []
            for _r in range(4):
                row_ln = next_line(lines_iter)
                if row_ln is None:
                    raise Exception("Unexpected EOF while reading joint matrix")
                parts = row_ln.split()
                if len(parts) != 4:
                    raise Exception(f"Expected 4 floats for matrix row, got: '{row_ln}'")
                rows.append(list(map(float, parts)))
            mat = mathutils.Matrix((rows[0], rows[1], rows[2], rows[3]))

            # find next line that looks like integer parent index
            parent_line = next_line(lines_iter)
            while parent_line is not None:
                # if it's an int-like single token -> use it
                toks = parent_line.split()
                if len(toks) == 1:
                    try:
                        parent_index = int(toks[0])
                        break
                    except ValueError:
                        pass
                # otherwise maybe stray, advance
                parent_line = next_line(lines_iter)
            if parent_line is None:
                raise Exception("Unexpected EOF while reading joint parent index")
            joints.append((name, mat))
            parent_indices.append(parent_index)

        # find 'vertices:' marker
        ln = next_line(lines_iter)
        while ln is not None and ln != "vertices:":
            ln = next_line(lines_iter)
        if ln is None:
            raise Exception("Expected 'vertices:' section")

        # read vertices: for each vertex read expected sequence of lines
        verts = []
        vert_normals = []
        vert_tangents = []
        vert_tangentw = []
        vert_uv = []
        vert_color_scales = []
        vert_mat_idx = []
        vert_weights = []
        vert_joint_ids = []

        for vi in range(vertex_count):
            # vertex id
            vid_ln = next_line(lines_iter)
            if vid_ln is None:
                raise Exception("Unexpected EOF while reading vertex id")
            try:
                _vid = int(vid_ln.split()[0])
            except ValueError:
                raise Exception(f"Expected vertex id integer, got: '{vid_ln}'")

            # position (3 floats)
            pos_ln = next_line(lines_iter)
            if pos_ln is None:
                raise Exception("Unexpected EOF while reading vertex position")
            pos = tuple(map(float, pos_ln.split()))
            if len(pos) != 3:
                raise Exception(f"Expected 3 floats for position, got: '{pos_ln}'")

            # normal (3 floats)
            normal_ln = next_line(lines_iter)
            normal = tuple(map(float, normal_ln.split()))
            # tangent (3 floats)
            tangent_ln = next_line(lines_iter)
            tangent = tuple(map(float, tangent_ln.split()))
            # tangentw (1 float)
            tw_ln = next_line(lines_iter)
            tangentw = float(tw_ln.split()[0])
            # uv (2 floats)
            uv_ln = next_line(lines_iter)
            uv = tuple(map(float, uv_ln.split()))
            # colorScale (int)
            cs_ln = next_line(lines_iter)
            color_scale = int(cs_ln.split()[0])
            # material index (int)
            mat_ln = next_line(lines_iter)
            mat_index = int(mat_ln.split()[0])
            # weights (4 floats)
            w_ln = next_line(lines_iter)
            weights = tuple(map(float, w_ln.split()))
            # joint ids (4 ints)
            j_ln = next_line(lines_iter)
            joint_ids = tuple(map(int, j_ln.split()))

            # optional blank separator - skip if present
            # (next_line would already skip blanks)

            verts.append(pos)
            vert_normals.append(normal)
            vert_tangents.append(tangent)
            vert_tangentw.append(tangentw)
            vert_uv.append(uv)
            vert_color_scales.append(color_scale)
            vert_mat_idx.append(mat_index)
            vert_weights.append(weights)
            vert_joint_ids.append(joint_ids)

        # find 'triangles:' marker
        ln = next_line(lines_iter)
        while ln is not None and ln != "triangles:":
            ln = next_line(lines_iter)
        if ln is None:
            raise Exception("Expected 'triangles:' section")
        tris = []
        for _ in range(triangle_count):
            tri_ln = next_line(lines_iter)
            if tri_ln is None:
                raise Exception("Unexpected EOF while reading triangles")
            tri = tuple(map(int, tri_ln.split()))
            tris.append(tri)

    # --- construct armature and mesh same as before ---
    arm_obj = None
    if len(joints) > 0:
        arm_data = bpy.data.armatures.new((object_name or "ImportedMesh") + "_armature")
        arm_obj = bpy.data.objects.new((object_name or "ImportedMesh") + "_armature_obj", arm_data)
        bpy.context.collection.objects.link(arm_obj)
        bpy.context.view_layer.objects.active = arm_obj
        bpy.ops.object.mode_set(mode='EDIT')
        edit_bones = arm_data.edit_bones
        created = []
        for idx, (name, _) in enumerate(joints):
            eb = edit_bones.new(name)
            eb.head = (0.0, 0.0, 0.0)
            eb.tail = (0.0, 0.1, 0.0)
            created.append(eb)
        for idx, parent_idx in enumerate(parent_indices):
            if parent_idx != -1:
                created[idx].parent = created[parent_idx]
        for idx, (_, mat) in enumerate(joints):
            created[idx].matrix = mat
        bpy.ops.object.mode_set(mode='OBJECT')

    mesh_data = bpy.data.meshes.new((object_name or "ImportedMesh") + "_mesh")
    mesh_obj = bpy.data.objects.new((object_name or "ImportedMesh"), mesh_data)
    bpy.context.collection.objects.link(mesh_obj)
    mesh_data.from_pydata(verts, [], tris)
    mesh_data.update()

    if vert_uv:
        uv_layer = mesh_data.uv_layers.new(name="UVMap")
        loop_uv = uv_layer.data
        for poly in mesh_data.polygons:
            for li in poly.loop_indices:
                v_idx = mesh_data.loops[li].vertex_index
                u, v = vert_uv[v_idx]
                loop_uv[li].uv = (u, v)

    if arm_obj is not None:
        mesh_obj.parent = arm_obj
        for idx, (name, _) in enumerate(joints):
            mesh_obj.vertex_groups.new(name=name)
        for v_idx, joint_ids in enumerate(vert_joint_ids):
            weights = vert_weights[v_idx]
            for slot, joint_id in enumerate(joint_ids):
                if joint_id != -1:
                    w = weights[slot] if slot < len(weights) else 0.0
                    vg = mesh_obj.vertex_groups[joints[joint_id][0]]
                    vg.add([v_idx], w, 'REPLACE')
        mod = mesh_obj.modifiers.new(name="Armature", type='ARMATURE')
        mod.object = arm_obj



    #mesh_data.use_auto_smooth = True

    return mesh_obj, arm_obj



def import_skinned_meshBAD(filepath: str, object_name: str = None):
    lines = list(_read_line_chunks(filepath))
    i = 0
    def take():
        nonlocal i
        if i >= len(lines):
            return None
        v = lines[i]
        i += 1
        return v

    # version line
    header = take()
    if header is None:
        raise Exception("Empty mesh file")
    # joint_count
    joint_count = 0
    vertex_count = 0
    triangle_count = 0
    while True:
        ln = take()
        if ln is None:
            break
        if ln.startswith("joint_count"):
            joint_count = int(ln.split()[1])
        elif ln.startswith("vertex_count"):
            vertex_count = int(ln.split()[1])
        elif ln.startswith("triangle_count"):
            triangle_count = int(ln.split()[1])
        elif ln == "joints:":
            break

    # read joints
    joints = []
    parent_indices = []
    for _ in range(joint_count):
        name = take()
        # next 4 lines are rows of matrix
        r0 = list(map(float, take().split()))
        r1 = list(map(float, take().split()))
        r2 = list(map(float, take().split()))
        r3 = list(map(float, take().split()))
        mat = mathutils.Matrix((r0, r1, r2, r3))
        parent_line = take()
        parent_index = int(parent_line)
        joints.append((name, mat))
        parent_indices.append(parent_index)

    # read vertices:
    # expect a "vertices:" line
    ln = take()
    if ln != "vertices:":
        raise Exception("Expected 'vertices:' in mesh file")
    verts = []
    vert_normals = []
    vert_tangents = []
    vert_tangentw = []
    vert_uv = []
    vert_color_scales = []
    vert_mat_idx = []
    vert_weights = []
    vert_joint_ids = []
    for _ in range(vertex_count):
        vid = int(take())
        pos = tuple(map(float, take().split()))
        normal = tuple(map(float, take().split()))
        tangent = tuple(map(float, take().split()))
        tw = float(take())
        uv = tuple(map(float, take().split()))
        color_scale = int(take())
        mat_index = int(take())
        weights = tuple(map(float, take().split()))
        joint_ids = tuple(map(int, take().split()))
        _ = take()  # blank separator possibly already skipped but safe
        verts.append(pos)
        vert_normals.append(normal)
        vert_tangents.append(tangent)
        vert_tangentw.append(tw)
        vert_uv.append(uv)
        vert_color_scales.append(color_scale)
        vert_mat_idx.append(mat_index)
        vert_weights.append(weights)
        vert_joint_ids.append(joint_ids)

    # read triangles:
    ln = take()
    if ln != "triangles:":
        raise Exception("Expected 'triangles:'")
    tris = []
    for _ in range(triangle_count):
        tri = tuple(map(int, take().split()))
        tris.append(tri)

    # Create armature if any joints
    arm_obj = None
    if joint_count > 0:
        arm_data = bpy.data.armatures.new((object_name or "ImportedMesh") + "_armature")
        arm_obj = bpy.data.objects.new((object_name or "ImportedMesh") + "_armature_obj", arm_data)
        bpy.context.collection.objects.link(arm_obj)
        bpy.context.view_layer.objects.active = arm_obj
        bpy.ops.object.mode_set(mode='EDIT')
        edit_bones = arm_data.edit_bones
        created = []
        for idx, (name, mat) in enumerate(joints):
            eb = edit_bones.new(name)
            # temporary head/tail â€” we will set matrix directly
            eb.head = (0.0, 0.0, 0.0)
            eb.tail = (0.0, 0.1, 0.0)
            created.append(eb)
        # set parenting
        for idx, parent_idx in enumerate(parent_indices):
            if parent_idx != -1:
                created[idx].parent = created[parent_idx]
        # set matrices
        for idx, (name, mat) in enumerate(joints):
            # edit_bone.matrix expects 4x4; set bone transform relative to armature object
            created[idx].matrix = mat
        bpy.ops.object.mode_set(mode='OBJECT')

    # Create mesh object
    mesh_data = bpy.data.meshes.new((object_name or "ImportedMesh") + "_mesh")
    mesh_obj = bpy.data.objects.new((object_name or "ImportedMesh"), mesh_data)
    bpy.context.collection.objects.link(mesh_obj)
    mesh_data.from_pydata(verts, [], tris)
    mesh_data.update()

    # UV
    if vert_uv:
        uv_layer = mesh_data.uv_layers.new(name="UVMap")
        # set UV per loop
        loop_uv = uv_layer.data
        loop_index = 0
        for poly in mesh_data.polygons:
            for li in poly.loop_indices:
                v_idx = mesh_data.loops[li].vertex_index
                u, v = vert_uv[v_idx]
                loop_uv[li].uv = (u, v)
                loop_index += 1

    # vertex groups and weights
    if arm_obj is not None:
        mesh_obj.parent = arm_obj
        # create vertex groups
        for idx, (name, _) in enumerate(joints):
            mesh_obj.vertex_groups.new(name=name)
        # assign weights
        for v_idx, joint_ids in enumerate(vert_joint_ids):
            weights = vert_weights[v_idx]
            for jslot, joint_id in enumerate(joint_ids):
                if joint_id != -1:
                    w = 0.0
                    if jslot < len(weights):
                        w = weights[jslot]
                    vg = mesh_obj.vertex_groups[joints[joint_id][0]]
                    vg.add([v_idx], w, 'REPLACE')
        # add armature modifier
        mod = mesh_obj.modifiers.new(name="Armature", type='ARMATURE')
        mod.object = arm_obj
    else:
        # no armature, nothing to do
        pass

    # Recalculate normals
    mesh_data.calc_normals_split()
    mesh_data.use_auto_smooth = True

    return mesh_obj, arm_obj

# ---------- animation importer ----------
def import_sampled_anim(filepath: str, armature_object: bpy.types.Object, action_name: str = None, start_frame: int = 1):
    # reads file and creates action on given armature
    with open(filepath, 'r', encoding='utf-8') as fh:
        lines = [ln.strip() for ln in fh if ln.strip()]

    it = iter(lines)
    header = next(it, None)  # version
    joint_count = 0
    sample_count = 0
    # read header fields
    while True:
        ln = next(it)
        if ln.startswith("joint_count"):
            joint_count = int(ln.split()[1])
        elif ln.startswith("sample_count"):
            sample_count = int(ln.split()[1])
            break

    # read joints
    joint_names = []
    joint_samples = []
    for _ in range(joint_count):
        name = next(it)
        joint_names.append(name)
        samples = []
        for _s in range(sample_count):
            pos_line = next(it); pos = tuple(map(float, pos_line.split()))
            ori_line = next(it); ori = tuple(map(float, ori_line.split()))  # x,y,z,w per exporter
            scl_line = next(it); scl = tuple(map(float, scl_line.split()))
            # skip blank maybe handled earlier
            samples.append((pos, ori, scl))
        joint_samples.append(samples)

    # create action
    if armature_object is None:
        raise Exception("No armature provided for animation import")
    action = bpy.data.actions.new(name=(action_name or "ImportedAction"))
    armature_object.animation_data_create()
    armature_object.animation_data.action = action

    # mapping joint name -> pose bone index
    pb_map = {pb.name: pb for pb in armature_object.pose.bones}

    # create curves for each bone present in file and in armature
    for j_idx, j_name in enumerate(joint_names):
        if j_name not in pb_map:
            # ignore bones missing in armature
            continue
        pb = pb_map[j_name]
        # fcurves for location x,y,z
        loc_paths = [ ("pose.bones[\"%s\"].location" % j_name, i) for i in range(3) ]
        rot_path = "pose.bones[\"%s\"].rotation_quaternion" % j_name
        scl_paths = [ ("pose.bones[\"%s\"].scale" % j_name, i) for i in range(3) ]

        # create fcurves
        loc_fcurves = [ action.fcurves.new(data_path=loc_paths[k][0], index=loc_paths[k][1]) for k in range(3) ]
        rot_fcurves = [ action.fcurves.new(data_path=rot_path, index=k) for k in range(4) ]
        scl_fcurves = [ action.fcurves.new(data_path=scl_paths[k][0], index=scl_paths[k][1]) for k in range(3) ]

        # insert keys
        for s_idx in range(sample_count):
            frame = start_frame + s_idx
            pos, ori_raw, scl = joint_samples[j_idx][s_idx]
            # ori_raw stored as (x,y,z,w) -> convert to (w,x,y,z)
            quat = (ori_raw[3], ori_raw[0], ori_raw[1], ori_raw[2])
            # insert location
            for k in range(3):
                loc_fcurves[k].keyframe_points.insert(frame, pos[k], options={'FAST'})
            # insert rotation quaternion
            for k in range(4):
                rot_fcurves[k].keyframe_points.insert(frame, quat[k], options={'FAST'})
            # insert scale
            for k in range(3):
                scl_fcurves[k].keyframe_points.insert(frame, scl[k], options={'FAST'})

    # set action to armature
    armature_object.animation_data.action = action
    return action

# ---------- convenience run function ----------
def import_skinned_pair(mesh_path: str, anim_path: str = None, base_name: str = None):
    mesh_name = base_name or "Imported"
    mesh_obj, arm_obj = import_skinned_mesh(mesh_path, object_name=mesh_name)
    action = None
    if anim_path and arm_obj is not None:
        action = import_sampled_anim(anim_path, arm_obj, action_name=(base_name or "ImportedAction"))
    return mesh_obj, arm_obj, action

# ---------- Example usage ----------
# Uncomment and edit paths, then run.
# mesh_obj, arm_obj, action = import_skinned_pair(
#     r"D:\z\MyMesh.skinned_mesh",
#     r"D:\z\MyAction.skinned_anim",
#     base_name="test_import"
# )


# Example usage:
#import_skinned_mesh("C:/path_to_existing_meshes/door.001.skinned_mesh")

#:tagLastLieneUsageReplacemanually
import_skinned_pair(r"D:/z/door.001.skinned_mesh")

