# WARNING; this procedure "from_mesh_and_armature_claude" was generated by AI (but AI had to use human made code and update it to blender 4.3) gotta spit the most probable token.
#for blender 4.3.something
import bpy
import bpy
import mathutils

from typing import (
    Dict,
    List,
    Tuple
)

from bpy.props import (
    IntProperty,
    BoolProperty,
    EnumProperty
)
from bpy_extras.io_utils import (
    ExportHelper,
    orientation_helper,
    axis_conversion
)

class Joint_Sample:
    def __init__ (
        self,
        local_position : Tuple[float, float, float],
        local_orientation : Tuple[float, float, float, float],
        local_scale : Tuple[float, float, float]
    ):
        self.local_position = local_position
        self.local_orientation = local_orientation
        self.local_scale = local_scale

class Joint_Animation:
    def __init__ (
        self,
        name : str
    ):
        self.name = name
        self.samples : List[Joint_Sample] = []

class Sampled_Animation:
    def __init__ (
        self
    ):
        self.sample_count : int = 0
        self.name_to_joint_id : Dict[str, int] = {}
        self.joints : List[Joint_Animation] = []

    def from_action (
        blender_obj : bpy.types.Object,
        blender_action : bpy.types.Action,
        frame_begin : int,
        frame_end : int,
        frame_step : int,
        transform_matrix : mathutils.Matrix
    ):
        def append_pose (
            anim : Sampled_Animation,
            pose : bpy.types.Pose
        ):
            for bone in pose.bones:
                # @Note (stefan): Is it possible for a bone to
                # spawn in the middle of an animation ? We don't
                # want that.
                if bone.name not in anim.name_to_joint_id:
                    continue
                matrix = transform_matrix @ bone.matrix
                if bone.parent is not None:
                    parent_matrix = transform_matrix @ bone.parent.matrix
                    matrix = parent_matrix.inverted () @ matrix
                location, orientation, scale = matrix.decompose ()
                joint_index = anim.name_to_joint_id[bone.name]
                anim.joints[joint_index].samples.append (
                    Joint_Sample (
                        tuple (location),
                        (
                            orientation[1],
                            orientation[2],
                            orientation[3],
                            orientation[0]
                        ),
                        tuple (scale)
                    )
                )

        result = Sampled_Animation ()
        prev_action = blender_obj.animation_data.action
        prev_frame  = bpy.context.scene.frame_current
        blender_obj.animation_data.action = blender_action

        # Initialize the joint animations array and name dict
        bpy.context.scene.frame_set (frame_begin)
        for bone in blender_obj.pose.bones:
            if not bone.bone.use_deform:
                continue
            joint_index = len (result.joints)
            joint_anim = Joint_Animation (bone.name)
            result.joints.append (joint_anim)
            result.name_to_joint_id.update ({ bone.name : joint_index })
        # Go through each frame in the animation and add the pose to the anim
        for frame in range (frame_begin, frame_end, frame_step):
            bpy.context.scene.frame_set (frame)
            append_pose (result, blender_obj.pose)
        bpy.context.scene.frame_set (prev_frame)
        blender_obj.animation_data.action = prev_action
        # Make sure we have the same number of samples for each joint
        if len (result.joints) > 0:
            result.sample_count = len (result.joints[0].samples)
        for joint in result.joints:
            if len (joint.samples) != result.sample_count:
                raise Exception (f"Inconsistent sample count for joints in animation {blender_action.name}.")

        return result

    def write_text (self, filename : str):
        with open (filename, "wb") as file:
            fw = file.write
            fw (b"[3]\n\n")	# Version
            fw (b"joint_count %u\n" % len (self.joints))
            fw (b"sample_count %u\n\n" % self.sample_count)
            for joint in self.joints:
                fw (b"%s\n\n" % bytes (joint.name, 'UTF-8'))
                for sample in joint.samples:
                    fw (b"%.6f %.6f %.6f\n" % sample.local_position[:])
                    fw (b"%.6f %.6f %.6f %.6f\n" % sample.local_orientation[:])
                    fw (b"%.6f %.6f %.6f\n\n" % sample.local_scale[:])

def export_animations (
    context : bpy.types.Context,
    filename : str,
    use_action_frame_range : bool,
    frame_step : int,
    use_selection : bool,
    apply_transform : bool,
    axis_conversion_matrix : mathutils.Matrix
):
    import os

    if bpy.ops.object.mode_set.poll ():
        bpy.ops.object.mode_set (mode = 'OBJECT')
    if use_selection:
        objs = context.selected_objects
    else:
        objs = context.scene.objects
    exported_actions : List[bpy.types.Action] = []
    for obj in objs:
        if obj.animation_data is None or obj.pose is None:
            continue
        action = obj.animation_data.action
        if action is None or action in exported_actions:
            continue
        transform_matrix = mathutils.Matrix.Identity (4)
        #TODO: Figure out a way to make this crap work.
        if apply_transform:
            transform_matrix = transform_matrix @ obj.matrix_world
        if axis_conversion_matrix is not None:
            transform_matrix = transform_matrix @ axis_conversion_matrix.to_4x4 ()
        output_filename = os.path.join (AnimExporter.output_dir, action.name) + AnimExporter.filename_ext
        if use_action_frame_range:
            frame_begin, frame_end = (
                int (action.frame_range[0]),
                int (action.frame_range[1])
            )
        else:
            frame_begin, frame_end = (
                int (context.scene.frame_start),
                int (context.scene.frame_end)
            )
        anim = Sampled_Animation.from_action (obj, action, frame_begin, frame_end, frame_step, transform_matrix)
        anim.write_text (output_filename)
        print (f"Exported animation clip {action.name} to file {output_filename}.\n")
        exported_actions.append (action)
    print("exported animation")

@orientation_helper (axis_forward = '-Z', axis_up = 'Y')
class AnimExporter (bpy.types.Operator, ExportHelper):
    """Export animation data"""
    bl_idname = "export.anim_example_anim"
    bl_label = "Export sampled animation (.anim)"
    bl_options = { 'REGISTER', 'UNDO' }
    filename_ext = ".skinned_anim"
    output_dir = "D:/z"

    use_selection : BoolProperty (
        name = "Only Selected",
        description = "Export only the active action of the selected objects.",
        default = True
    )
    apply_transform : BoolProperty (
        name = "Apply object transform",
        description = "Apply the object transform matrix when exporting animations.",
        default = True
    )
    use_action_frame_range : BoolProperty (
        name = "Use action frame range",
        description = "Use the action frame range rather than the scene frame range.",
        default = False
    )
    frame_step : IntProperty (
        name = "Frame step",
        description = "How many frames to advance when sampling the animation.",
        default = 1
    )

    def execute (self, context : bpy.types.Context):
        context.window.cursor_set ('WAIT')
        export_animations (
            context,
            self.filepath,
            self.use_action_frame_range,
            self.frame_step,
            self.use_selection,
            self.apply_transform,
            axis_conversion (to_forward = self.axis_forward, to_up = self.axis_up)
        )
        context.window.cursor_set ('DEFAULT')

        return { 'FINISHED' }

def export_menu_func (self, context : bpy.types.Context):
    self.layout.operator (AnimExporter.bl_idname)


import bpy
import bmesh
import mathutils

from typing import (
    List,
    Dict,
    Tuple
)
from bpy.props import (
    StringProperty,
    BoolProperty,
    FloatProperty
)
from bpy_extras.io_utils import (
    ExportHelper,
    orientation_helper,
    axis_conversion
)

class Vertex:
    def __init__ (
        self,
        verticeId: int, #because I like to reserve the word Vertex for this class because IDE limitations.
        position  : Tuple[float, float, float],
        normal    : Tuple[float, float, float],
        tangent: Tuple[float, float, float],
        tangentw: float,
        texcoord_0: Tuple[float, float],
        colorScale: int,
        material_index: int,
        joint_ids : Tuple[int, int, int, int],
        weights   : Tuple[float, float, float, float]
    ):
        self.verticeId = verticeId

        self.position = position
        self.normal = normal

        self.tangent = tangent
        self.tangentw = tangentw

        self.texcoord_0 = texcoord_0
        self.colorScale = colorScale
        self.material_index = material_index


        self.joint_ids = joint_ids
        self.weights = weights


class Mesh:
    def __init__ (
        self
    ):
        self.name_to_joint_id : Dict[str, int] = {}
        self.joints : List[bpy.types.Bone] = []
        self.verts : List[Vertex] = []
        self.tris : List[Tuple[int, int, int]] = []


    def from_mesh_and_armature_claude(
        blender_obj: bpy.types.Object,
        blender_mesh: bpy.types.Mesh,
        blender_armature: bpy.types.Armature
    ):
        def append_hierarchy(joints: List[bpy.types.Bone], bone: bpy.types.Bone):
            joints.append(bone)
            for child in bone.children:
                if child.use_deform:
                    append_hierarchy(joints, child)

        def groups_to_tuple4(a):
            if len(a) == 0:
                return -1, -1, -1, -1
            elif len(a) == 1:
                return a[0], -1, -1, -1
            elif len(a) == 2:
                return a[0], a[1], -1, -1
            elif len(a) == 3:
                return a[0], a[1], a[2], -1
            return a[0], a[1], a[2], a[3]

        def weights_to_tuple3(a):
            if len(a) == 0:
                return 0, 0, 0
            elif len(a) == 1:
                return round(a[0], 6), 0, 0
            elif len(a) == 2:
                return round(a[0], 6), round(a[1], 6), 0
            return round(a[0], 6), round(a[1], 6), round(a[2], 6)

        def weights_to_tuple4(a):
            if len(a) == 0:
                return 0, 0, 0, 0
            elif len(a) == 1:
                return round(a[0], 6), 0, 0, 0
            elif len(a) == 2:
                return round(a[0], 6), round(a[1], 6), 0, 0
            elif len(a) == 3:
                return round(a[0], 6), round(a[1], 6), round(a[2], 6), 0
            elif len(a) == 4:
                return round(a[0], 6), round(a[1], 6), round(a[2], 6), round(a[3], 6)

        def normalize_weights(weights):
            total = sum(weights)
            if total == 0:
                return weights
            return [w / total for w in weights]

        result = Mesh()

        # Setup armature data (unchanged)
        if blender_armature is not None:
            root = None
            for b in blender_armature.bones:
                if b.parent is None and b.use_deform:
                    if root is not None:
                        raise Exception("Found multiple root bones in armature.")
                    root = b
            if root is None:
                raise Exception("Could not find root bone.")
            append_hierarchy(result.joints, root)
            if len(result.joints) > 0x7fff:
                raise Exception(f"Armature has {len(result.joints)} bones, which is more than the maximum allowed ({0x7fff}).")
            for i, b in enumerate(result.joints):
                result.name_to_joint_id.update({b.name: i})

        # Calculate tangents
        blender_mesh.calc_tangents()
        vert_group_names = {g.index: g.name for g in blender_obj.vertex_groups}

        # SOLUTION: Simple fix - just create vertices in original order first
        # Build a lookup of vertex_index -> first_loop_data for each vertex
        vertex_loop_data = {}

        # Collect loop data for each vertex (use first occurrence)
        for poly in blender_mesh.polygons:
            material_index = poly.material_index
            for j in range(poly.loop_total):
                loop_index = poly.loop_start + j
                loop = blender_mesh.loops[loop_index]
                vert_index = loop.vertex_index

                # Only store data for first occurrence of this vertex
                if vert_index not in vertex_loop_data:
                    uv_layer = blender_mesh.uv_layers.active
                    if uv_layer is not None:
                        orig_uv = uv_layer.data[loop_index].uv
                        texcoord_0 = (orig_uv.x, 1.0 - orig_uv.y)
                    else:
                        texcoord_0 = (0.0, 0.0)

                    vertex_loop_data[vert_index] = {
                        'normal': tuple(loop.normal),
                        'tangent': tuple(loop.tangent),
                        'tangentw': 1.0,
                        'texcoord_0': texcoord_0,
                        'material_index': material_index
                    }

        # Now create vertices in original Blender order
        for vert_index in range(len(blender_mesh.vertices)):
            vert = blender_mesh.vertices[vert_index]

            # Get loop data (or use defaults)
            if vert_index in vertex_loop_data:
                loop_data = vertex_loop_data[vert_index]
                normal = loop_data['normal']
                tangent = loop_data['tangent']
                tangentw = loop_data['tangentw']
                texcoord_0 = loop_data['texcoord_0']
                material_index = loop_data['material_index']
            else:
                # Fallback for unused vertices
                normal = tuple(vert.normal)
                tangent = (1.0, 0.0, 0.0)
                tangentw = 1.0
                texcoord_0 = (0.0, 0.0)
                material_index = 0

            colorScale = 0xFFFFFFFF

            # Handle vertex groups and weights (unchanged logic)
            has_armature_and_groups = True
            if len(vert.groups) != 0 and blender_armature is None:
                has_armature_and_groups = False

            if has_armature_and_groups and len(vert.groups) > 0:
                if len(vert.groups) > 4:
                    sorted_groups = sorted(vert.groups, key=lambda g: g.weight, reverse=True)[:4]
                    weights = [g.weight for g in sorted_groups]
                    weights = normalize_weights(weights)
                    groups = [g.group for g in sorted_groups]
                else:
                    groups = [g.group for g in vert.groups]
                    weights = [g.weight for g in vert.groups]
            else:
                groups = []
                weights = []

            groups = groups_to_tuple4(groups)
            weights = weights_to_tuple4(weights)
            joint_ids = [-1 for i in range(len(groups))]

            for i in range(len(groups)):
                if groups[i] != -1:
                    name = vert_group_names[groups[i]]
                    if name not in result.name_to_joint_id:
                        raise Exception(f"Vertex is assigned to group {name} but we could not find a deform bone with this name in the armature.")
                    joint_ids[i] = result.name_to_joint_id[name]

            result.verts.append(Vertex(
                vert_index,
                tuple(vert.co),
                normal,
                tangent,
                tangentw,
                texcoord_0,
                colorScale,
                material_index,
                tuple(joint_ids),
                weights
            ))

        # Create triangles using original vertex indices
        for poly in blender_mesh.polygons:
            if len(poly.vertices) != 3:
                raise Exception("Mesh has polygons that are not triangles. Make sure to triangulate the mesh prior.")

            tri = []
            for j in range(poly.loop_total):
                loop_index = poly.loop_start + j
                loop = blender_mesh.loops[loop_index]
                vert_index = loop.vertex_index  # This is the original Blender vertex index
                tri.append(vert_index)  # Use it directly since we created vertices in order

            result.tris.append((tri[0], tri[1], tri[2]))

        return result

    def write_text (self, filename : str):
        with open (filename, "wb") as file:
            fw = file.write
            fw (b"[3]\n\n") # Version
            fw (b"joint_count %u\n" % len (self.joints))
            fw (b"vertex_count %u\n" % len (self.verts))
            fw (b"triangle_count %u\n\n" % len (self.tris))
            fw (b"joints:\n")
            flipo = axis_conversion(from_forward='-Y', from_up='Z', to_forward='Z', to_up='Y').to_4x4() #Seems to work
            flipo = axis_conversion(from_forward='-Z', from_up='Y', to_forward='Z', to_up='Y').to_4x4()

            for joint in self.joints:
                fw (b"%s\n" % bytes (joint.name, 'UTF-8'))
                if joint.parent is not None:
                    local_transform = joint.parent.matrix_local.inverted () @ joint.matrix_local
                else:
                    local_transform = joint.matrix_local
                # local_transform = flipo @ local_transform
                # local_transform =  local_transform @ flipo
                local_transform =  local_transform
                fw (b"%.6f %.6f %.6f %.6f\n" % local_transform[0][:])
                fw (b"%.6f %.6f %.6f %.6f\n" % local_transform[1][:])
                fw (b"%.6f %.6f %.6f %.6f\n" % local_transform[2][:])
                fw (b"%.6f %.6f %.6f %.6f\n" % local_transform[3][:])
                if joint.parent is not None:
                    fw (b"%u\n\n" % self.name_to_joint_id[joint.parent.name])
                else:
                    fw (b"-1\n\n")
            fw (b"vertices:\n")
            for vert in self.verts:
                fw(b"%u\n" % vert.verticeId)
                fw (b"%.6f %.6f %.6f\n" % vert.position)
                fw (b"%.6f %.6f %.6f\n" % vert.normal)
                fw(b"%.6f %.6f %.6f\n" % vert.tangent)
                fw(b"%.6f\n" % vert.tangentw)
                fw(b"%.6f %.6f\n" % vert.texcoord_0)
                fw(b"%u\n" % vert.colorScale)
                fw(b"%u\n" % vert.material_index)
                fw (b"%.6f %.6f %.6f %.6f\n" % vert.weights)
                fw (b"%i %i %i %i\n" % vert.joint_ids)
                fw (b"\n")
            fw (b"triangles:\n")
            for tri in self.tris:
                fw (b"%u %u %u\n" % tuple (tri))


def export_meshes (
    context : bpy.types.Context,
    filename : str,
    use_selection : bool,
    apply_transform : bool,
    axis_conversion_matrix : mathutils.Matrix
):
    import os

    if bpy.ops.object.mode_set.poll ():
        bpy.ops.object.mode_set (mode = 'OBJECT')
    if use_selection:
        objs = context.selected_objects
    else:
        objs = context.scene.objects
    for obj in objs:
        try:
            #old 3.6: me = obj.to_mesh ()
            depsgraph = context.evaluated_depsgraph_get()
            eval_obj = obj.evaluated_get(depsgraph)
            me = eval_obj.to_mesh(preserve_all_data_layers=True, depsgraph=depsgraph)
        except RuntimeError:
            continue
        armature_obj = obj.find_armature ()
        armature = bpy.types.Armature = None
        if armature_obj is not None:
            armature = armature_obj.data.copy ()
        # Apply object transform and calculate normals
        if apply_transform:
            me.transform (obj.matrix_world)
            if armature is not None:
                armature.transform (obj.matrix_world)
        if axis_conversion_matrix is not None:
            me.transform (axis_conversion_matrix.to_4x4 ())
            if armature is not None:
                armature.transform (axis_conversion_matrix.to_4x4 ())
        #me.mesh_normals_make_consistent(False)
        # Triangulate mesh
        bm = bmesh.new ()
        bm.from_mesh (me)
        bmesh.ops.triangulate (bm, faces = bm.faces[:])
        bm.to_mesh (me)
        bm.free ()

        #result = Mesh.from_mesh_and_armature (obj, me, armature)
        result = Mesh.from_mesh_and_armature_claude (obj, me, armature)
        output_filename = os.path.join (MeshExporter.output_dir, obj.name) + MeshExporter.filename_ext
        result.write_text (output_filename)
        #old 3.6: obj.to_mesh_clear ()
        # bpy.data.meshes.remove(me)

        print (f"Exported mesh {obj.name} to file {output_filename}.\n")
    print("exported meshes")

@orientation_helper (axis_forward = '-Z', axis_up = 'Y')
class MeshExporter (bpy.types.Operator, ExportHelper):
    """Export mesh data"""
    bl_idname = "export.anim_example_mesh"
    bl_label = "Export mesh with skinning (.mesh)"
    bl_options = { 'REGISTER', 'UNDO' }
    filename_ext = ".skinned_mesh"
    output_dir = "D:/z"

    use_selection : BoolProperty (
        name = "Only Selected",
        description = "Export only the selected meshes.",
        default = True
    )
    apply_transform : BoolProperty (
        name = "Apply object transform",
        description = "Apply the object transform matrix when exporting meshes.",
        default = False
    )

    def execute (self, context : bpy.types.Context):
        context.window.cursor_set ('WAIT')
        export_meshes (
            context,
            self.filepath,
            self.use_selection,
            self.apply_transform,
            axis_conversion (to_forward = self.axis_forward, to_up = self.axis_up)
        )
        context.window.cursor_set ('DEFAULT')

        return { 'FINISHED' }

def export_menu_func (self, context : bpy.types.Context):
    self.layout.operator (MeshExporter.bl_idname)



export_meshes (
    bpy.context,
    "unusedname1",
    use_selection = True,
    apply_transform = False,
    #axis_conversion_matrix = axis_conversion (to_forward = 'Z', to_up = 'Y')  # for DirectX, basically rotate -90Â° X
    axis_conversion_matrix = axis_conversion(from_forward='-Y', from_up='Z',to_forward='Z',to_up='Y') #Seems to work
    # axis_conversion_matrix = axis_conversion(from_forward='-Z', from_up='Y', to_forward='Z', to_up='Y')

    #axis_conversion_matrix = axis_conversion (to_forward = '-Z', to_up = 'Y') #from jai
    #axis_conversion_matrix = None
)

export_animations (
    bpy.context,
    "unisedanimname1",
    use_action_frame_range = False,
    frame_step = 1,
    use_selection = True,
    apply_transform = True,
    axis_conversion_matrix = axis_conversion(from_forward='-Y', from_up='Z',to_forward='Z',to_up='Y')
     #   axis_conversion_matrix = axis_conversion (to_forward = '-Z', to_up = 'Y')
)
