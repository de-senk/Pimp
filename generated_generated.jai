//File autogenerated by build_dll.jai ----
simulate : #type () -> void;// #foreign pimp;
create_solver_and_world : #type () -> void;// #foreign pimp;
l2w : #type (world_position: Vector3, Aori: Quaternion, local_point: Vector3) -> Vector3;// #foreign pimp;
l2w_rotate_only : #type (world_position: Vector3, Aori: Quaternion, local_point: Vector3) -> Vector3;// #foreign pimp;
w2l : #type (world_position: Vector3, orientation: Quaternion, world_point: Vector3) -> Vector3;// #foreign pimp;
w2l_rotate_only : #type (_: Vector3, orientation: Quaternion, world_point: Vector3) -> Vector3;// #foreign pimp;

//
// STRUCTS
//
Solver :: struct {
    using world: *World;
    dt := 1.0 / 60.0;
    gravity := Vector3.{0, -10, 0};
    iterations := 10;
    number_of_steps_executed_so_far: u64;
};

World :: struct {
    VOLOR :: struct {
        p: Vector3;
        radius: float;
        color: Vector4;
    }
    counter: u64;
    count_Constraint_Fitted_To_PageSize :: 8 * 4096 / size_of(Constraint);
    count_RigidBody_Fitted_To_PageSize :: 8 * 4096 / size_of(Body);
    bodies: Bucket_Array(type = Body, items_per_bucket = count_RigidBody_Fitted_To_PageSize);
    constraints: Bucket_Array(type = Constraint, items_per_bucket = count_Constraint_Fitted_To_PageSize);
    points_to_draw: [10] VOLOR;
    points_to_draw_cursor: int;
};


STUD_PROC_POINTERS:= **void.[
cast(*void)(*simulate),
cast(*void)(*create_solver_and_world),
cast(*void)(*l2w),
cast(*void)(*l2w_rotate_only),
cast(*void)(*w2l),
cast(*void)(*w2l_rotate_only),
];

STUD_PROC_LIST :: string.[
"simulate",
"create_solver_and_world",
"l2w",
"l2w_rotate_only",
"w2l",
"w2l_rotate_only",
];
