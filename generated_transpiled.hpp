// Auto-generated by build_transpile_to_c_with_overloads.jai
// Date: {9581146850400000000, 0}

#ifndef GENERATED_TRANSPILED_HPP
#define GENERATED_TRANSPILED_HPP

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

// Jai type mappings
typedef int8_t   s8;
typedef int16_t  s16;
typedef int32_t  s32;
typedef int64_t  s64;
typedef uint8_t  u8;
typedef uint16_t u16;
typedef uint32_t u32;
typedef uint64_t u64;
typedef float    f32;
typedef double   f64;

// Forward declarations
struct MONITORINFO;
struct NUMA_NODE_RELATIONSHIP;
struct Joint_Constraint;
struct Code_Push_Context;
struct Polymorph_Report;
struct STACKFRAME64;
struct CRITICAL_SECTION_stub;
struct OVERLAPPED;
struct Newstring;
struct Code_Note;
struct X64_Options;
struct Vector2;
struct MEMORY_BASIC_INFORMATION;
struct Code_Using;
struct MEMORYSTATUSEX;
struct Code_Declaration;
struct Message_Performance_Report;
struct Heap_Size_Class;
struct ULARGE_INTEGER;
struct Code_Directive_Place;
struct Message_Complete;
struct Code_Defer;
struct MMTIME;
struct SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX;
struct Log_Section;
struct IUnknown;
struct Code_Directive_Insert;
struct FormatInt;
struct Matrix3;
struct MINIDUMP_USER_STREAM_INFORMATION;
struct MINIDUMP_MEMORY_INFO;
struct OSVERSIONINFOEXW;
struct JOBOBJECT_BASIC_LIMIT_INFORMATION;
struct Code_Directive_Library;
struct CONSOLE_SCREEN_BUFFER_INFO;
struct Code_Node;
struct Message_Typechecked;
struct Simplest_Geometric_Shape;
struct Code_Directive_Module_Parameters;
struct Table;
struct MINIDUMP_USER_STREAM;
struct Vector4;
struct Temporary_Storage;
struct FILTERKEYS;
struct Matrix4;
struct Compiler_Pin;
struct Plane3;
struct RGBQUAD;
struct Code_For;
struct Code_Type_Instantiation;
struct Global_Statistics;
struct SYSTEM_CPU_SET_INFORMATION;
struct Code_Directive_Load;
struct SYSTEMTIME;
struct Code_Argument;
struct Basic_Shape;
struct BITMAP;
struct TOGGLEKEYS;
struct Simd_128;
struct Type_Info_Array;
struct POINT;
struct PROCESS_INFORMATION;
struct AnyMatrix3;
struct BITMAPFILEHEADER;
struct BITMAPINFO;
struct Message_Import;
struct Matrix2;
struct OSVERSIONINFOW;
struct Any_Struct;
struct Code_Pointer_Literal_Info;
struct Code_Loop_Control;
struct GROUP_RELATIONSHIP;
struct M128A;
struct FILE_FULL_DIR_INFO;
struct SMALL_RECT;
struct SECURITY_ATTRIBUTES;
struct Context_Base;
struct Type_Info_Float;
struct Time_Report;
struct MINIDUMP_EXCEPTION_INFORMATION;
struct FILE_STANDARD_INFO;
struct Body;
struct FormatStruct;
struct JOBOBJECT_EXTENDED_LIMIT_INFORMATION;
struct Code_If;
struct WNDCLASSEXW;
struct Type_Info_Integer;
struct Bucket;
struct Stack_Trace_Node;
struct IMAGEHLP_LINE64;
struct PROCESSOR_GROUP_INFO;
struct SYSTEM_INFO;
struct Linear_Compliance;
struct XSAVE_FORMAT;
struct Message;
struct Type_Info;
struct Code_Comma_Separated_Argument;
struct RAWMOUSE;
struct Code_Ident;
struct Source_Code_Location;
struct Code_Directive_Exists;
struct Message_File;
struct RAWINPUTHEADER;
struct AnyMatrix4x3;
struct Resizable_Array;
struct Code_Literal;
struct Code_Directive_Location;
struct Code_Directive_Context_Type;
struct LARGE_INTEGER;
struct AnyMatrix2;
struct FILE_END_OF_FILE_INFO;
struct Formatter;
struct Code_Struct_Literal_Info;
struct OSVERSIONINFOEXA;
struct IMAGEHLP_SYMBOL64;
struct TIME_ZONE_INFORMATION;
struct IO_COUNTERS;
struct Soft_Body;
struct Two_Body_Constraint_Shared;
struct S128;
struct Vector6;
struct Type_Info_String;
struct CONDITION_VARIABLE;
struct Span;
struct Code_Type_Definition;
struct Memory_Debugger_Interface;
struct Print_Style;
struct Stack_Trace_Procedure_Info;
struct Code_Directive_Through;
struct Code_Directive_Bake;
struct Code_Procedure_Call;
struct Type_Info_Procedure;
struct U128;
struct bunnyMesh;
struct FormatArray;
struct Llvm_Options;
struct Code_Compound_Declaration;
struct BITMAPINFOHEADER;
struct AnyVector2;
struct World;
struct MINIDUMP_CALLBACK_INFORMATION;
struct Type_Info_Variant;
struct MSG;
struct Code_Directive_Import;
struct AnyMatrix;
struct Code_Directive_Code;
struct STICKYKEYS;
struct EXCEPTION_RECORD;
struct ICONINFO;
struct FormatFloat;
struct Code_Directive_Modify;
struct Code_Cast;
struct Message_Debug_Dump;
struct FILE_NOTIFY_INFORMATION;
struct EXCEPTION_POINTERS;
struct FILETIME;
struct SIZE;
struct Code_Placeholder;
struct Type_Info_Pointer;
struct Array_View_64;
struct Bivector;
struct Version_Info;
struct OSVERSIONINFOA;
struct RECT;
struct RTL_CRITICAL_SECTION;
struct Code_Extract;
struct Heap_Statistics;
struct GUID;
struct SHFILEOPSTRUCTA;
struct Code_Return;
struct Code_Unary_Operator;
struct Code_Directive_Add_Context;
struct RAWHID;
struct PROCESSOR_RELATIONSHIP;
struct WNDCLASSEXA;
struct Code_Asm;
struct Memcpy_Map;
struct Typechecked;
struct physics_coordinates;
struct Global_Data_Info;
struct PIXELFORMATDESCRIPTOR;
struct Size_Class;
struct Code_Binary_Operator;
struct Build_Options_During_Compile;
struct Type_Info_Enum;
struct Code_Struct;
struct Code_Directive_Poke_Name;
struct RAWKEYBOARD;
struct Code_Directive_Run;
struct Source_Code_Range;
struct Type_Info_Struct;
struct Procedure_With_Data;
struct FloatInt64;
struct Metaprogram_Plugin;
struct Bucket_Locator;
struct Code_Expression_Query;
struct COORD;
struct Code_Array_Literal_Info;
struct Code_Directive_Scope;
struct Message_Phase;
struct Code_Procedure_Body;
struct Calendar_Time;
struct Code_Directive_Wildcard;
struct Bytecode_Report;
struct GROUP_AFFINITY;
struct String_Builder;
struct IMAGEHLP_LINEW64;
struct Code_While;
struct Build_Options;
struct OPENFILENAME;
struct RAWINPUTDEVICE;
struct MINIDUMP_CALLBACK_OUTPUT;
struct WIN32_FIND_DATAW;
struct CURSORINFO;
struct CACHE_RELATIONSHIP;
struct Code_Enum;
struct Code_Type_Query;
struct Heap;
struct Solver;
struct Message_Failed_Import;
struct Matrix6;
struct Code_Directive_Bytes;
struct ADDRESS64;
struct Log_Info;
struct MINIDUMP_CALLBACK_INPUT;
struct MINIDUMP_EXCEPTION_INFORMATION64;
struct Bucket_Array;
struct AABB;
struct Run_Directive_Report;
struct Code_Context;
struct ICONINFOEXW;
struct CONTEXT;
struct SIMD_Array;
struct Runtime_Info;
struct Vector3;
struct Code_Block;
struct RAWINPUT;
struct STARTUPINFOA;
struct SHFILEOPSTRUCTW;
struct Allocator;
struct Rotor;
struct Code_Resolved_Overload;
struct SYMBOL_INFO;
struct Code_Procedure_Header;
struct Code_Scope_Entry;
struct FLASHWINFO;
struct Code_Make_Varargs;
struct Type_Info_Struct_Member;
struct TIMECAPS;
struct Matrix_RC;
struct Temporary_Storage_State;
struct IUnknown_VTable;
struct Quaternion;
struct Global_Data_Segment_Info;
struct KDHELP64;
struct Code_Comma_Separated_Arguments;
struct LIST_ENTRY;
struct RTL_CRITICAL_SECTION_DEBUG;
struct Code_Case;
struct LUID;
struct HexDouble;
struct Matrix4x3;
struct Data_Segment;
struct Code_Directive_Procedure_Name;
struct STARTUPINFOW;

// Enumerations
enum Get_Root_Type_Status {
    UNINITIALIZED = ,
    SUCCESS = 1,
    INPUT_IS_CODE_NULL = 2,
    CORRUPTED = 3,
    NOT_TYPED = 4,
};

enum TOGGLEKEY_FLAGS {
    TKF_TOGGLEKEYSON = 1,
    TKF_AVAILABLE = 2,
    TKF_HOTKEYACTIVE = 4,
    TKF_CONFIRMHOTKEY = 8,
    TKF_HOTKEYSOUND = 16,
    TKF_INDICATOR = 32,
};

enum Log_Flags {
    NONE = ,
    ERROR = 1,
    WARNING = 2,
    CONTENT = 4,
    TO_FILE_ONLY = 8,
    VERBOSE_ONLY = 16,
    VERY_VERBOSE_ONLY = 32,
    TOPIC_ONLY = 64,
};

enum STICKYKEY_FLAGS {
    SKF_STICKYKEYSON = 1,
    SKF_AVAILABLE = 2,
    SKF_HOTKEYACTIVE = 4,
    SKF_CONFIRMHOTKEY = 8,
    SKF_HOTKEYSOUND = 16,
    SKF_INDICATOR = 32,
    SKF_AUDIBLEFEEDBACK = 64,
    SKF_TRISTATE = 128,
    SKF_TWOKEYSOFF = 256,
};

enum ADDRESS_MODE {
    AddrMode1616 = ,
    AddrMode1632 = 1,
    AddrModeReal = 2,
    AddrModeFlat = 3,
};

enum FILE_INFO_BY_HANDLE_CLASS {
};

enum Enum_Type_Flags {
    FLAGS = 1,
    COMPLETE = 2,
    SPECIFIED = 4,
};

enum Optimization_Type {
    DEBUG = ,
    VERY_DEBUG = 1,
    OPTIMIZED = 2,
    VERY_OPTIMIZED = 3,
    OPTIMIZED_SMALL = 4,
    OPTIMIZED_VERY_SMALL = 5,
};

enum Report {
    ERROR = ,
    ERROR_CONTINUABLE = 1,
    WARNING = 2,
    INFO = 3,
};

enum Struct_Status_Flags {
    INCOMPLETE = 1,
    LOCAL = 4,
};

enum FINDEX_SEARCH_OPS {
};

enum Allocator_Mode {
    ALLOCATE = ,
    RESIZE = 1,
    FREE = 2,
    STARTUP = 3,
    SHUTDOWN = 4,
    THREAD_START = 5,
    THREAD_STOP = 6,
    CREATE_HEAP = 7,
    DESTROY_HEAP = 8,
    IS_THIS_YOURS = 9,
    CAPS = 10,
};

enum Shape_Kind {
    SPHEREvsSPHERE = 0,
    SPHEREvsCAPSULE = 0,
    SPHEREvsPLANE = 0,
    CAPSULEvsPLANE = 0,
};

enum SYMOPT {
    CASE_INSENSITIVE = 1,
    UNDNAME = 2,
    DEFERRED_LOADS = 4,
    NO_CPP = 8,
    LOAD_LINES = 16,
    OMAP_FIND_NEAREST = 32,
    LOAD_ANYTHING = 64,
    IGNORE_CVREC = 128,
    NO_UNQUALIFIED_LOADS = 256,
    FAIL_CRITICAL_ERRORS = 512,
    EXACT_SYMBOLS = 1024,
    ALLOW_ABSOLUTE_SYMBOLS = 2048,
    IGNORE_NT_SYMPATH = 4096,
    INCLUDE_32BIT_MODULES = 8192,
    PUBLICS_ONLY = 16384,
    NO_PUBLICS = 32768,
    AUTO_PUBLICS = 65536,
    NO_IMAGE_SEARCH = 131072,
    SECURE = 262144,
    NO_PROMPTS = 524288,
    OVERWRITE = 1048576,
    IGNORE_IMAGEDIR = 2097152,
    FLAT_DIRECTORY = 4194304,
    FAVOR_COMPRESSED = 8388608,
    ALLOW_ZERO_ADDRESS = 16777216,
    DISABLE_SYMSRV_AUTODETECT = 33554432,
    READONLY_CACHE = 67108864,
    SYMPATH_LAST = 134217728,
    DISABLE_FAST_SYMBOLS = 268435456,
    DISABLE_SYMSRV_TIMEOUT = 536870912,
    DISABLE_SRVSTAR_ON_STARTUP = 1073741824,
    DEBUG = 2147483648,
};

enum DPI_AWARENESS {
    DPI_AWARENESS_INVALID = -1,
    DPI_AWARENESS_UNAWARE = ,
    DPI_AWARENESS_SYSTEM_AWARE = 1,
    DPI_AWARENESS_PER_MONITOR_AWARE = 2,
};

enum Job_Object_Limit {
    JOB_OBJECT_LIMIT_WORKINGSET = 1,
    JOB_OBJECT_LIMIT_PROCESS_TIME = 2,
    JOB_OBJECT_LIMIT_JOB_TIME = 4,
    JOB_OBJECT_LIMIT_ACTIVE_PROCESS = 8,
    JOB_OBJECT_LIMIT_AFFINITY = 16,
    JOB_OBJECT_LIMIT_PRIORITY_CLASS = 32,
    JOB_OBJECT_LIMIT_PRESERVE_JOB_TIME = 64,
    JOB_OBJECT_LIMIT_SCHEDULING_CLASS = 128,
    JOB_OBJECT_LIMIT_PROCESS_MEMORY = 256,
    JOB_OBJECT_LIMIT_JOB_MEMORY = 512,
    JOB_OBJECT_LIMIT_JOB_MEMORY_HIGH = JOB_OBJECT_LIMIT_JOB_MEMORY,
    JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION = 1024,
    JOB_OBJECT_LIMIT_BREAKAWAY_OK = 2048,
    JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK = 4096,
    JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE = 8192,
    JOB_OBJECT_LIMIT_SUBSET_AFFINITY = 16384,
    JOB_OBJECT_LIMIT_JOB_MEMORY_LOW = 32768,
    JOB_OBJECT_LIMIT_JOB_READ_BYTES = 65536,
    JOB_OBJECT_LIMIT_JOB_WRITE_BYTES = 131072,
    JOB_OBJECT_LIMIT_RATE_CONTROL = 262144,
    JOB_OBJECT_LIMIT_CPU_RATE_CONTROL = JOB_OBJECT_LIMIT_RATE_CONTROL,
    JOB_OBJECT_LIMIT_IO_RATE_CONTROL = 524288,
    JOB_OBJECT_LIMIT_NET_RATE_CONTROL = 1048576,
};

enum Creation_Flags {
    DEBUG_PROCESS = 1,
    DEBUG_ONLY_THIS_PROCESS = 2,
    CREATE_SUSPENDED = 4,
    DETACHED_PROCESS = 8,
    CREATE_NEW_CONSOLE = 16,
    NORMAL_PRIORITY_CLASS = 32,
    IDLE_PRIORITY_CLASS = 64,
    HIGH_PRIORITY_CLASS = 128,
    REALTIME_PRIORITY_CLASS = 256,
    CREATE_NEW_PROCESS_GROUP = 512,
    CREATE_UNICODE_ENVIRONMENT = 1024,
    CREATE_SEPARATE_WOW_VDM = 2048,
    CREATE_SHARED_WOW_VDM = 4096,
    CREATE_FORCEDOS = 8192,
    BELOW_NORMAL_PRIORITY_CLASS = 16384,
    ABOVE_NORMAL_PRIORITY_CLASS = 32768,
    INHERIT_PARENT_AFFINITY = 65536,
    INHERIT_CALLER_PRIORITY = 131072,
    CREATE_PROTECTED_PROCESS = 262144,
    EXTENDED_STARTUPINFO_PRESENT = 524288,
    PROCESS_MODE_BACKGROUND_BEGIN = 1048576,
    PROCESS_MODE_BACKGROUND_END = 2097152,
    CREATE_SECURE_PROCESS = 4194304,
    CREATE_BREAKAWAY_FROM_JOB = 16777216,
    CREATE_PRESERVE_CODE_AUTHZ_LEVEL = 33554432,
    CREATE_DEFAULT_ERROR_MODE = 67108864,
    CREATE_NO_WINDOW = 134217728,
    PROFILE_USER = 268435456,
    PROFILE_KERNEL = 536870912,
    PROFILE_SERVER = 1073741824,
    CREATE_IGNORE_SYSTEM_DEFAULT = 2147483648,
};

enum ROP {
    SRCCOPY = 13369376,
};

enum Workspace_Status {
    OK = ,
    FAILED = 1,
};

enum BOOL {
    FALSE = ,
    TRUE = 1,
};

enum IMAGE_FILE_MACHINE {
    I386 = 332,
    IA64 = 512,
    AMD64 = 34404,
};

enum For_Flags {
    POINTER = 1,
    REVERSE = 2,
    TEMPORARY_V2 = 4,
};

enum Type_Info_Tag {
    INTEGER = ,
    FLOAT = 1,
    BOOL = 2,
    STRING = 3,
    POINTER = 4,
    PROCEDURE = 5,
    VOID = 6,
    STRUCT = 7,
    ARRAY = 8,
    OVERLOAD_SET = 9,
    ANY = 10,
    ENUM = 11,
    POLYMORPHIC_VARIABLE = 12,
    TYPE = 13,
    CODE = 14,
    UNTYPED_LITERAL = 15,
    UNTYPED_ENUM = 16,
    VARIANT = 18,
};

enum LOGICAL_PROCESSOR_RELATIONSHIP {
    RelationAll = 65535,
};

enum Time_Zone {
    UTC = ,
    LOCAL = 1,
};

enum Type_Info_Variant_Flags {
    DISTINCT = 1,
    ISA = 2,
};

enum JOBOBJECTINFOCLASS {
    BasicAccountingInformation = 1,
    Reserved1Information = 18,
    Reserved14Information = 31,
    Reserved15Information = 37,
    Reserved16Information = 38,
    Reserved17Information = 39,
    Reserved18Information = 40,
    Reserved19Information = 41,
    Reserved20Information = 42,
    Reserved21Information = 43,
    Reserved22Information = 44,
    Reserved23Information = 45,
    Reserved24Information = 46,
    Reserved25Information = 47,
};

enum Struct_Nontextual_Flags {
    NOT_INSTANTIABLE = 4,
    ALL_MEMBERS_UNINITIALIZED = 64,
    POLYMORPHIC = 256,
};

enum Llvm_Machine_Code_Optimization_Setting {
    UNSET = ,
    NONE = 1,
    LESS = 2,
    DEFAULT = 3,
    AGGRESSIVE = 4,
};

enum Operator_Type {
    IS_EQUAL = 131,
    IS_NOT_EQUAL = 132,
    LOGICAL_AND = 133,
    LOGICAL_OR = 134,
    LESS_OR_EQUAL = 135,
    GREATER_OR_EQUAL = 136,
    SHIFT_LEFT = 137,
    SHIFT_RIGHT = 138,
    ROTATE_LEFT = 139,
    ROTATE_RIGHT = 140,
    PLUS_ASSIGN = 145,
    MINUS_ASSIGN = 146,
    TIMES_ASSIGN = 147,
    DIV_ASSIGN = 148,
    MOD_ASSIGN = 149,
    SHIFT_LEFT_ASSIGN = 150,
    SHIFT_RIGHT_ASSIGN = 151,
    ROTATE_LEFT_ASSIGN = 152,
    ROTATE_RIGHT_ASSIGN = 153,
    BITWISE_AND_ASSIGN = 154,
    BITWISE_OR_ASSIGN = 155,
    BITWISE_XOR_ASSIGN = 156,
    LOGICAL_AND_ASSIGN = 157,
    LOGICAL_OR_ASSIGN = 158,
    POINTER_DEREFERENCE = 168,
    POSTFIX_DEREFERENCE = 169,
    ARRAY_SUBSCRIPT = 500,
};

enum FINDEX_INFO_LEVELS {
};

enum PROCESSOR_CACHE_TYPE {
};

enum BOOLEAN {
    FALSE = ,
    TRUE = 1,
};

enum MINIDUMP_TYPE {
    MiniDumpNormal = ,
    MiniDumpWithDataSegs = 1,
    MiniDumpWithFullMemory = 2,
    MiniDumpWithHandleData = 4,
    MiniDumpFilterMemory = 8,
    MiniDumpScanMemory = 16,
    MiniDumpWithUnloadedModules = 32,
    MiniDumpWithIndirectlyReferencedMemory = 64,
    MiniDumpFilterModulePaths = 128,
    MiniDumpWithProcessThreadData = 256,
    MiniDumpWithPrivateReadWriteMemory = 512,
    MiniDumpWithoutOptionalData = 1024,
    MiniDumpWithFullMemoryInfo = 2048,
    MiniDumpWithThreadInfo = 4096,
    MiniDumpWithCodeSegs = 8192,
    MiniDumpWithoutAuxiliaryState = 16384,
    MiniDumpWithFullAuxiliaryState = 32768,
    MiniDumpWithPrivateWriteCopyMemory = 65536,
    MiniDumpIgnoreInaccessibleMemory = 131072,
    MiniDumpWithTokenInformation = 262144,
    MiniDumpWithModuleHeaders = 524288,
    MiniDumpFilterTriage = 1048576,
    MiniDumpWithAvxXStateContext = 2097152,
    MiniDumpWithIptTrace = 4194304,
    MiniDumpScanInaccessiblePartialPages = 8388608,
    MiniDumpFilterWriteCombinedMemory = 16777216,
    MiniDumpValidTypeFlags = 33554431,
};

enum Log_Level {
    NORMAL = ,
    VERBOSE = 1,
    VERY_VERBOSE = 2,
};

enum Msvc_Destructor_Flags {
    NONE = ,
    FREE_MEMORY = 1,
    ARRAY_DESTRUCTOR = 2,
};

enum MINIDUMP_CALLBACK_TYPE {
};

enum Operating_System_Tag {
    NONE = ,
    KRAMPOS = 1,
    WINDOWS = 2,
    LINUX = 3,
    ANDROID = 4,
    IOS = 5,
    MACOS = 6,
    NN_SWITCH = 7,
    PS4 = 8,
    PS5 = 9,
    XBOX = 10,
    WASM = 11,
    OUNCE = 12,
};

enum FILEOP_FLAGS {
    FOF_MULTIDESTFILES = 1,
    FOF_CONFIRMMOUSE = 2,
    FOF_SILENT = 4,
    FOF_RENAMEONCOLLISION = 8,
    FOF_NOCONFIRMATION = 16,
    FOF_WANTMAPPINGHANDLE = 32,
    FOF_ALLOWUNDO = 64,
    FOF_FILESONLY = 128,
    FOF_SIMPLEPROGRESS = 256,
    FOF_NOCONFIRMMKDIR = 512,
    FOF_NOERRORUI = 1024,
    FOF_NOCOPYSECURITYATTRIBS = 2048,
    FOF_NORECURSION = 4096,
    FOF_NO_CONNECTED_ELEMENTS = 8192,
    FOF_WANTNUKEWARNING = 16384,
    FOF_NORECURSEREPARSE = 32768,
    FOF_NO_UI = 0,
};

enum SetFilePointer_MoveMethod {
    FILE_BEGIN = ,
    FILE_CURRENT = 1,
    FILE_END = 2,
};

enum SEM {
    SEM_FAILCRITICALERRORS = 1,
    SEM_NOALIGNMENTFAULTEXCEPT = 4,
    SEM_NOGPFAULTERRORBOX = 2,
    SEM_NOOPENFILEERRORBOX = 32768,
};

enum FILTERKEY_FLAGS {
    FKF_FILTERKEYSON = 1,
    FKF_AVAILABLE = 2,
    FKF_HOTKEYACTIVE = 4,
    FKF_CONFIRMHOTKEY = 8,
    FKF_HOTKEYSOUND = 16,
    FKF_INDICATOR = 32,
    FKF_CLICKON = 64,
};

enum Provided_Import_Type {
    SHORT_NAME = ,
    PATH_TO_FILE = 1,
    PATH_TO_DIRECTORY = 2,
    FULL_TEXT = 3,
};

enum Struct_Textual_Flags {
    FOREIGN = 1,
    UNION = 2,
    NO_PADDING = 4,
    TYPE_INFO_NONE = 8,
    TYPE_INFO_NO_SIZE_COMPLAINT = 16,
    TYPE_INFO_PROCEDURES_ARE_VOID_POINTERS = 32,
};

enum MONITOR_DPI_TYPE {
};

enum Data_Segment_Characteristics {
    READ = 1,
    WRITE = 2,
    EXECUTE = 4,
    ZEROED = 8,
};

enum Enum_Status_Flags {
    INCOMPLETE = 1,
};

enum Allocator_Caps {
    MULTIPLE_THREADS = 1,
    CREATE_HEAP = 2,
    FREE = 4,
    ACTUALLY_RESIZE = 8,
    IS_THIS_YOURS = 16,
    HINT_I_AM_A_FAST_BUMP_ALLOCATOR = 16777216,
    HINT_I_AM_A_GENERAL_HEAP_ALLOCATOR = 33554432,
    HINT_I_AM_PER_FRAME_TEMPORARY_STORAGE = 67108864,
    HINT_I_AM_A_DEBUG_ALLOCATOR = 134217728,
};

enum Type_Info_Flags {
    NO_TYPE_INFO = 1,
    PROCEDURES_ARE_VOID_POINTERS = 2,
    NO_SIZE_COMPLAINT = 4,
};

enum Data_Segment_Index {
    WRITABLE = ,
    WRITABLE_NO_RESET = 1,
    READ_ONLY = 2,
    BSS = 3,
    USER_SEGMENT = 16,
};

enum Llvm_Bitcode_Optimization_Setting {
    UNSET = ,
    O0 = 1,
    O1 = 2,
    O2 = 3,
    O3 = 4,
    OS = 5,
    OZ = 6,
};

enum Intercept_Flags {
    SKIP_EXPRESSIONS_WITHOUT_NOTES = 1,
    SKIP_DECLARATIONS = 2,
    SKIP_PROCEDURE_HEADERS = 4,
    SKIP_PROCEDURE_BODIES = 8,
    SKIP_STRUCTS = 16,
    SKIP_OTHERS = 32,
    SKIP_ALL = 0,
    DO_PERFORMANCE_REPORT_POLYMORPHS = 4096,
    DO_PERFORMANCE_REPORT_RUNS = 8192,
};

enum FLASHW {
    FLASHW_STOP = ,
    FLASHW_CAPTION = 1,
    FLASHW_TRAY = 2,
    FLASHW_ALL = 3,
    FLASHW_TIMER = 4,
    FLASHW_TIMERNOFG = 12,
};

enum CPU_Tag {
    UNINITIALIZED = ,
    KRAMPU = 1,
    CUSTOM = 2,
    X64 = 3,
    ARM64 = 4,
};

enum Joint_Kinds {
};

enum BLTMODE {
    BLACKONWHITE = 1,
    WHITEONBLACK = 2,
    COLORONCOLOR = 3,
    HALFTONE = 4,
};

enum PROCESS_DPI_AWARENESS {
    PROCESS_DPI_UNAWARE = ,
    PROCESS_SYSTEM_DPI_AWARE = 1,
    PROCESS_PER_MONITOR_DPI_AWARE = 2,
};


// Type definitions
typedef  void;
typedef  v128;
typedef  s32;
typedef  float;
typedef  float64;
typedef  Any;
typedef  s8;
typedef  s16;
typedef  u32;
typedef  u64;
typedef  float32;
typedef  Code;
typedef  Type;
typedef  string;
typedef  u8;
typedef  s64;
typedef  REPLACEMENT_INTERFACE;
typedef  bool;
typedef  int;
typedef  u16;

// Structures
struct MONITORINFO {
    s32 cbSize;
    RECT rcMonitor;
    RECT rcWork;
    s32 dwFlags;
};

struct NUMA_NODE_RELATIONSHIP {
    u32 NodeNumber;
    u8* Reserved[18];
    u16 GroupCount;
    GROUP_AFFINITY GroupMask;
};

struct Joint_Constraint {
    void pre_solve;
    void solve_position;
    void solve_orientation;
    void apply_linear_damping;
    void apply_angular_damping;
    void target_length;
    void linear_compliance;
    void distanceMin;
    void distanceMax;
    void linearDampingCoeff;
    void swingMin;
    void swingMax;
    void twistMin;
    void twistMax;
    void targetAngle;
    void hasTargetAngle;
    void angular_compliance;
    void angularDampingCoeff;
    void velocity;
};

struct Code_Push_Context {
    Code_Node* to_push;
    Code_Block* block;
    void push_context_flags;
};

struct Polymorph_Report {
    s64 num_solves_invoked;
    s64 num_solves_used;
    void reported;
    void Record;
    void Distinct_Polymorph;
    Record* records;
};

struct STACKFRAME64 {
    ADDRESS64 AddrPC;
    ADDRESS64 AddrReturn;
    ADDRESS64 AddrFrame;
    ADDRESS64 AddrStack;
    ADDRESS64 AddrBStore;
    void* FuncTableEntry;
    u64* Params[4];
    BOOL Far;
    BOOL Virtual;
    u64* Reserved[3];
    KDHELP64 KdHelp;
};

struct CRITICAL_SECTION_stub {
    u64* memory[5];
};

struct OVERLAPPED {
    u64 Internal;
    u64 Status;
    u64 InternalHigh;
    u64 NumberOfBytesTransferred;
    HANDLE hEvent;
};

struct Newstring {
    s64 count;
    u8* data;
};

struct Code_Note {
    char* text;
    u32 note_flags;
};

struct X64_Options {
    void use_dlls;
    void enable_register_allocation;
    void enable_unix_runtime_frame_information;
};

struct Vector2 {
    f32* component[2];
};

struct MEMORY_BASIC_INFORMATION {
    void* BaseAddress;
    void* AllocationBase;
    DWORD AllocationProtect;
    WORD PartitionId;
    SIZE_T RegionSize;
    DWORD State;
    DWORD Protect;
    DWORD Type;
};

struct Code_Using {
    Code_Node* expression;
    void filter_type;
    Code_Node* filter_expression;
    void no_parameters;
};

struct MEMORYSTATUSEX {
    u32 dwLength;
    u32 dwMemoryLoad;
    u64 ullTotalPhys;
    u64 ullAvailPhys;
    u64 ullTotalPageFile;
    u64 ullAvailPageFile;
    u64 ullTotalVirtual;
    u64 ullAvailVirtual;
    u64 ullAvailExtendedVirtual;
};

struct Code_Declaration {
    Code_Type_Instantiation* type_inst;
    Code_Node* expression;
    void flags;
    Code_Node* alignment_expression;
    Code_Note** notes;
    char* program_export_name;
};

struct Message_Performance_Report {
    Time_Report time_report;
    Run_Directive_Report run_directive_report;
    Polymorph_Report polymorph_report;
    Bytecode_Report bytecode_report;
};

struct Heap_Size_Class {
    void* free_list;
    Span* partial_span;
    Span* cache;
};

struct ULARGE_INTEGER {
    u64 QuadPart;
};

struct Code_Directive_Place {
    Code_Ident* ident;
};

struct Message_Complete {
    void error_code;
};

struct Code_Defer {
    Code_Block* block;
    bool is_backticked;
};

struct MMTIME {
    u32 wType;
    void u;
};

struct SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX {
    LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
    u32 Size;
};

struct Log_Section {
    char* name;
};

struct IUnknown {
    IUnknown_VTable* vtable;
};

struct Code_Directive_Insert {
    Code_Node* expression;
    Code_Node* scope_redirection;
    Code_Node* break_replacement;
    Code_Node* continue_replacement;
    Code_Node* remove_replacement;
    Code_Node* expansion;
    void is_internal;
};

struct FormatInt {
    void base;
    void minimum_digits;
    u8 padding;
    u16 digits_per_comma;
    void comma_string;
};

struct Matrix3 {
    Vector3* v[3];
    f32** coef[3];
    f32* floats[9];
    void Row_Type;
    void Column_Type;
    void IsMatrixFromMathModule;
};

struct MINIDUMP_USER_STREAM_INFORMATION {
    u32 UserStreamCount;
    MINIDUMP_USER_STREAM* UserStreamArray;
};

struct MINIDUMP_MEMORY_INFO {
    u64 BaseAddress;
    u64 AllocationBase;
    u32 AllocationProtect;
    u32 __alignment1;
    u64 RegionSize;
    u32 State;
    u32 Protect;
    u32 Type;
    u32 __alignment2;
};

struct OSVERSIONINFOEXW {
    u16 wServicePackMajor;
    u16 wServicePackMinor;
    u16 wSuiteMask;
    u8 wProductType;
    u8 wReserved;
};

struct JOBOBJECT_BASIC_LIMIT_INFORMATION {
    u64 PerProcessUserTimeLimit;
    u64 PerJobUserTimeLimit;
    Job_Object_Limit LimitFlags;
    SIZE_T MinimumWorkingSetSize;
    SIZE_T MaximumWorkingSetSize;
    u32 ActiveProcessLimit;
    u32* Affinity;
    u32 PriorityClass;
    u32 SchedulingClass;
};

struct Code_Directive_Library {
    char* name;
    void library_flags;
};

struct CONSOLE_SCREEN_BUFFER_INFO {
    u16 wAttributes;
    SMALL_RECT srWindow;
    COORD dwMaximumWindowSize;
};

struct Code_Node {
    void Kind;
    void kind;
    void node_flags;
    Type_Info* type;
    void Location;
    s64 serial;
};

struct Message_Typechecked {
    void* declarations;
    void* procedure_headers;
    void* procedure_bodies;
    void* structs;
    void* others;
    void* all;
};

struct Simplest_Geometric_Shape {
    Vector3 a;
    Vector3 b;
    Vector3 c;
    Vector3 d;
    s64 count;
    Vector3* points[4];
    void state;
};

struct Code_Directive_Module_Parameters {
    Code_Procedure_Header* module_parameters;
    Code_Procedure_Header* program_parameters;
    Code_Block* common_code;
};

struct Table {
    s64 count;
    s64 allocated;
    s64 slots_filled;
    Allocator allocator;
    void Entry;
    Entry* entries;
    void SIZE_MIN;
};

struct MINIDUMP_USER_STREAM {
    u32 Type;
    u32 BufferSize;
    void* Buffer;
};

struct Vector4 {
    Vector2 xy;
    Vector2 yz;
    Vector2 zw;
    Vector3 xyz;
    Vector3 yzw;
    f32* component[4];
};

struct Temporary_Storage {
    u8* data;
    s64 size;
    s64 current_page_bytes_occupied;
    s64 total_bytes_occupied;
    s64 high_water_mark;
    Source_Code_Location last_set_mark_location;
    Allocator overflow_allocator;
    Overflow_Page* overflow_pages;
    u8* original_data;
    s64 original_size;
    void Overflow_Page;
};

struct FILTERKEYS {
    u32 cbSize;
    FILTERKEY_FLAGS dwFlags;
    u32 iWaitMSec;
    u32 iDelayMSec;
    u32 iRepeatMSec;
    u32 iBounceMSec;
};

struct Matrix4 {
    Matrix4x3 mat4x3;
    Vector4* v[4];
    f32** coef[4];
    f32* floats[16];
    void Row_Type;
    void Column_Type;
    void IsMatrixFromMathModule;
};

struct Compiler_Pin {
    char* name;
    char* pin;
};

struct Plane3 {
    Vector4 vector4;
    Vector3 normal;
};

struct RGBQUAD {
    u8 rgbBlue;
    u8 rgbGreen;
    u8 rgbRed;
    u8 rgbReserved;
};

struct Code_For {
    Code_Node* iteration_expression;
    Code_Node* iteration_expression_right;
    Code_Block* block;
    Code_Ident* ident_it;
    Code_Ident* ident_it_index;
    Code_Declaration* ident_decl;
    Code_Declaration* index_decl;
    Code_Node* want_replacement_for_expansion;
    Code_Node* want_pointer_expression;
    Code_Node* want_reverse_expression;
    Code_Procedure_Call* macro_expansion_procedure_call;
    For_Flags for_flags;
};

struct Code_Type_Instantiation {
    Type_Info* result;
    Code_Node* type_valued_expression;
    Code_Node* must_implement;
    Code_Type_Instantiation* pointer_to;
    Code_Type_Instantiation* type_directive_target;
    Code_Type_Instantiation* array_element_type;
    Code_Node* array_dimension;
    void inst_flags;
};

struct Global_Statistics {
    s64 mapped;
    s64 mapped_peak;
    s64 cached;
    s64 huge_alloc;
    s64 huge_alloc_peak;
    s64 mapped_total;
    s64 unmapped_total;
};

struct SYSTEM_CPU_SET_INFORMATION {
    u32 Size;
    void Type;
};

struct Code_Directive_Load {
    char* short_name;
    char* fully_pathed_filename;
    char* loaded_string;
    s32 load_flags;
};

struct SYSTEMTIME {
    u16 wYear;
    u16 wMonth;
    u16 wDayOfWeek;
    u16 wDay;
    u16 wHour;
    u16 wMinute;
    u16 wSecond;
    u16 wMilliseconds;
};

struct Code_Argument {
    Code_Node* expression;
    Code_Ident* name;
};

struct Basic_Shape {
    f32 capsule_radius;
    f32 capsule_height;
    f32 capsule_unused;
    f32 sphere_radius;
    f32 sphere_unused;
    f32 sphere_unused2;
};

struct BITMAP {
    u32 bmType;
    u32 bmWidth;
    u32 bmHeight;
    u32 bmWidthBytes;
    u16 bmPlanes;
    u16 bmBitsPixel;
    void* bmBits;
};

struct TOGGLEKEYS {
    u32 cbSize;
    TOGGLEKEY_FLAGS dwFlags;
};

struct Simd_128 {
    void _u8;
    void _s8;
    void _u16;
    void _s16;
    void _u32;
    void _s32;
    void _u64;
    void _s64;
    void _float32;
    void _float64;
};

struct Type_Info_Array {
    Type_Info* element_type;
    Array_Type array_type;
    s64 array_count;
    void Array_Type;
};

struct POINT {
};

struct PROCESS_INFORMATION {
    HANDLE hProcess;
    HANDLE hThread;
    u32 dwProcessId;
    u32 dwThreadId;
};

struct AnyMatrix3 {
};

struct BITMAPFILEHEADER {
    u16 bfType;
    u32 bfSize;
    u16 bfReserved1;
    u16 bfReserved2;
    u32 bfOffBits;
};

struct BITMAPINFO {
    BITMAPINFOHEADER bmiHeader;
    RGBQUAD* bmiColors[1];
};

struct Message_Import {
    void module_type;
    char* module_name;
    char* fully_pathed_filename;
};

struct Matrix2 {
    Vector2* v[2];
    f32** coef[2];
    f32* floats[4];
    void Row_Type;
    void Column_Type;
    void IsMatrixFromMathModule;
};

struct OSVERSIONINFOW {
    u32 dwOSVersionInfoSize;
    u32 dwMajorVersion;
    u32 dwMinorVersion;
    u32 dwBuildNumber;
    u32 dwPlatformId;
    u16* szCSDVersion[128];
};

struct Any_Struct {
    Type_Info* type;
    void* value_pointer;
};

struct Code_Pointer_Literal_Info {
    u8* data_pointer;
    void pointer_literal_type;
    s64 offset_from_symbol;
};

struct Code_Loop_Control {
    void control_type;
    Code_Ident* target_ident;
};

struct GROUP_RELATIONSHIP {
    u16 MaximumGroupCount;
    u16 ActiveGroupCount;
    u8* Reserved[20];
    PROCESSOR_GROUP_INFO GroupInfo;
};

struct M128A {
    u64 Low;
    s64 High;
};

struct FILE_FULL_DIR_INFO {
    u32 NextEntryOffset;
    u32 FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    u32 FileAttributes;
    u32 FileNameLength;
    u32 EaSize;
    u16* FileName[1];
};

struct SMALL_RECT {
};

struct SECURITY_ATTRIBUTES {
    u32 nLength;
    void* lpSecurityDescriptor;
    BOOL bInheritHandle;
};

struct Context_Base {
    Type_Info_Struct* context_info;
    u32 thread_index;
    void allocator;
    void logger;
    void* logger_data;
    u64 log_source_identifier;
    Log_Level log_level;
    Temporary_Storage* temporary_storage;
    Stack_Trace_Node* stack_trace;
    void assertion_failed;
    void handling_assertion_failure;
    void default_allocator;
};

struct Type_Info_Float {
};

struct Time_Report {
    f64 run_directives;
    f64 bytecode_inlining;
    f64 bytecode_generating;
};

struct MINIDUMP_EXCEPTION_INFORMATION {
    DWORD ThreadId;
    EXCEPTION_POINTERS* ExceptionPointers;
    BOOL ClientPointers;
};

struct FILE_STANDARD_INFO {
    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER EndOfFile;
    u32 NumberOfLinks;
    BOOLEAN DeletePending;
    BOOLEAN Directory;
};

struct Body {
    Bucket_Locator bucket_locator;
    Shape_Kind shape_kind;
    f32 radius;
    f32 capsule_height;
    Vector3 position;
    Vector3 prev_position;
    Vector3 velocity;
    Vector3 prev_velocity;
    Vector3 guess_position;
    Quaternion guess_orientation;
    Quaternion orientation;
    Quaternion prev_orientation;
    Vector3 angular_velocity;
    Vector3 prev_angular_velocity;
    Vector3 local_center_of_mass;
    f32 inv_mass;
    Vector3 inv_local_moment_of_inertia;
    f32 factor_energy_loss_on_collision;
    f32 friction;
    f32 elasticity;
    AABB local_aabb;
    Matrix3 inv_world_moment_of_inertia;
    u64 latest_frame_of_existence;
    void end_frame_callback;
    void* user_data;
    u64 hash;
};

struct FormatStruct {
    void draw_type_name;
    void use_long_form_if_more_than_this_many_members;
    void separator_between_name_and_value;
    void short_form_separator_between_fields;
    void long_form_separator_between_fields;
    void begin_string;
    void end_string;
    s32 indentation_width;
    void use_newlines_if_long_form;
};

struct JOBOBJECT_EXTENDED_LIMIT_INFORMATION {
    JOBOBJECT_BASIC_LIMIT_INFORMATION BasicLimitInformation;
    IO_COUNTERS IoInfo;
    SIZE_T ProcessMemoryLimit;
    SIZE_T JobMemoryLimit;
    SIZE_T PeakProcessMemoryUsed;
    SIZE_T PeakJobMemoryUsed;
};

struct Code_If {
    Code_Node* condition;
    Code_Block* then_block;
    Code_Block* else_block;
    void if_flags;
    void static_if_flags;
    Code_Case* static_if_accepted_case;
};

struct WNDCLASSEXW {
    u32 cbSize;
    u32 style;
    void lpfnWndProc;
    s32 cbClsExtra;
    s32 cbWndExtra;
    HINSTANCE hInstance;
    HICON hIcon;
    HCURSOR hCursor;
    HBRUSH hbrBackground;
    u16* lpszMenuName;
    u16* lpszClassName;
    HICON hIconSm;
};

struct Type_Info_Integer {
    bool signed;
};

struct Bucket {
    bool* occupied[items_per_bucket];
    type* data[items_per_bucket];
    s32 lowest_maybe_not_occupied;
    u32 bucket_index;
    void count;
};

struct Stack_Trace_Node {
    Stack_Trace_Node* next;
    Stack_Trace_Procedure_Info* info;
    u64 hash;
    u32 call_depth;
    u32 line_number;
};

struct IMAGEHLP_LINE64 {
    u32 SizeOfStruct;
    void* Key;
    u32 LineNumber;
    u8* FileName;
    u64 Address;
};

struct PROCESSOR_GROUP_INFO {
    u8 MaximumProcessorCount;
    u8 ActiveProcessorCount;
    u8* Reserved[38];
    u64 ActiveProcessorMask;
};

struct SYSTEM_INFO {
    u32 _pad0;
    u32 dwPageSize;
    u32* _pad1[8];
    u32 dwAllocationGranularity;
    u32 _pad2;
};

struct Linear_Compliance {
    void GOMU_GOMU;
    void NOT_SO_GOMU;
    void TARZAN_VINE;
    void WEAK_SPRING;
    void MEDIUM_SPRING;
    void STRONG_SPRING;
    void STEEL_ROD;
};

struct XSAVE_FORMAT {
    u16 ControlWord;
    u16 StatusWord;
    u8 TagWord;
    u8 Reserved1;
    u16 ErrorOpcode;
    u32 ErrorOffset;
    u16 ErrorSelector;
    u16 Reserved2;
    u32 DataOffset;
    u16 DataSelector;
    u16 Reserved3;
    u32 MxCsr;
    u32 MxCsr_Mask;
    M128A* FloatRegisters[8];
};

struct Message {
    void kind;
    Workspace workspace;
};

struct Type_Info {
    Type_Info_Tag type;
    s64 runtime_size;
};

struct Code_Comma_Separated_Argument {
    Code_Node* node;
    void modifier;
};

struct RAWMOUSE {
    u16 usFlags;
    u32 ulRawButtons;
    s32 lLastX;
    s32 lLastY;
    u32 ulExtraInformation;
};

struct Code_Ident {
    char* name;
    Code_Declaration* resolved_declaration;
    void flags;
};

struct Source_Code_Location {
    char* fully_pathed_filename;
    s64 line_number;
    s64 character_number;
};

struct Code_Directive_Exists {
    Code_Node* query_expression;
    Code_Node* sync_expression;
};

struct Message_File {
    char* fully_pathed_filename;
    Message_Import* enclosing_import;
    bool from_a_string;
};

struct RAWINPUTHEADER {
    u32 dwType;
    u32 dwSize;
    HANDLE hDevice;
    WPARAM wParam;
};

struct AnyMatrix4x3 {
};

struct Resizable_Array {
    s64 count;
    void* data;
    s64 allocated;
    Allocator allocator;
};

struct Code_Literal {
    void value_type;
    void value_flags;
};

struct Code_Directive_Location {
    Code_Node* expression;
    void is_caller_location;
};

struct Code_Directive_Context_Type {
};

struct LARGE_INTEGER {
    s64 QuadPart;
};

struct AnyMatrix2 {
};

struct FILE_END_OF_FILE_INFO {
    LARGE_INTEGER EndOfFile;
};

struct Formatter {
    Any value;
};

struct Code_Struct_Literal_Info {
    Code_Type_Instantiation* type_expression;
    Code_Node** arguments;
};

struct OSVERSIONINFOEXA {
    u16 wServicePackMajor;
    u16 wServicePackMinor;
    u16 wSuiteMask;
    u8 wProductType;
    u8 wReserved;
};

struct IMAGEHLP_SYMBOL64 {
    u32 SizeOfStruct;
    u64 Address;
    u32 Size;
    u32 Flags;
    u32 MaxNameLength;
    u8* Name[1];
};

struct TIME_ZONE_INFORMATION {
};

struct IO_COUNTERS {
    u64 ReadOperationCount;
    u64 WriteOperationCount;
    u64 OtherOperationCount;
    u64 ReadTransferCount;
    u64 WriteTransferCount;
    u64 OtherTransferCount;
};

struct Soft_Body {
    bool is_initialized;
    bool should_try_solve;
    bool is_graphics_initialized;
    s64 numParticles;
    s64 numTets;
    f32* pos;
    f32* prevPos;
    f32* vel;
    u32* tetIds;
    u32* edgeIds;
    u32* triangleList;
    f32* restVol;
    f32* edgeLengths;
    f32* invMass;
    f32 edgeCompliance;
    f32 volCompliance;
    f32* tempp;
    f32* grads;
    s32 grabId;
    f32 grabInvMass;
    void volIdOrder;
};

struct Two_Body_Constraint_Shared {
    Body* A;
    Body* B;
    Bucket_Locator bucket_locator;
    u64 latest_frame_of_existence;
    u64 hash;
    bool disabled;
    Vector3 world_position;
    Vector3 local_attach_position_A;
    Vector3 local_attach_position_B;
    Quaternion local_attach_orientation_A;
    Quaternion local_attach_orientation_B;
    Vector3 world_attach_position_A;
    Vector3 world_attach_position_B;
    Quaternion world_attach_orientation_A;
    Quaternion world_attach_orientation_B;
    Vector3 local_ref_A;
    Vector3 local_ref_B;
};

struct S128 {
    u64 low;
    s64 high;
};

struct Vector6 {
    Vector3 linear;
    Vector3 angular;
    f32* component[6];
};

struct Type_Info_String {
};

struct CONDITION_VARIABLE {
    void* Ptr;
};

struct Span {
    void* free_list;
    u32 block_count;
    u32 size_class;
    u32 free_list_limit;
    u32 used_count;
    void* free_list_deferred;
    u32 list_size;
    u32 block_size;
    void flags;
    u32 span_count;
    u32 total_spans;
    u32 offset_from_master;
    s32 remaining_spans;
    u32 align_offset;
    Heap* heap;
    Span* next;
    Span* prev;
};

struct Code_Type_Definition {
    Type_Info* info;
};

struct Memory_Debugger_Interface {
    void check_alloc;
    void check_free;
    void check_realloc;
    void check_create_heap;
    void check_destroy_heap;
};

struct Print_Style {
    FormatInt default_format_int;
    FormatFloat default_format_float;
    FormatStruct default_format_struct;
    FormatArray default_format_array;
    FormatInt default_format_absolute_pointer;
    void struct_printer;
    void* struct_printer_data;
    s32 indentation_depth;
    void log_runtime_errors;
};

struct Stack_Trace_Procedure_Info {
    char* name;
    Source_Code_Location location;
    void* procedure_address;
};

struct Code_Directive_Through {
};

struct Code_Directive_Bake {
    Code_Procedure_Call* procedure_call;
    void bake_type;
};

struct Code_Procedure_Call {
    Code_Node* procedure_expression;
    Code_Node* resolved_procedure_expression;
    Code_Declaration*** overloads;
    Code_Argument* arguments_unsorted;
    Code_Node** arguments_sorted;
    s64 num_return_values_received;
    Code_Block* macro_expansion_block;
    Context_Modification* context_modification;
    Flags flags;
    void Flags;
    void Context_Modification;
};

struct Type_Info_Procedure {
    Type_Info** argument_types;
    Type_Info** return_types;
    Flags procedure_flags;
    void Flags;
};

struct U128 {
    u64 low;
    u64 high;
};

struct bunnyMesh {
    void name;
    void verts;
    void tetIds;
    void tetEdgeIds;
    void tetSurfaceTriIds;
};

struct FormatArray {
    void separator;
    void begin_string;
    void end_string;
    void printing_stopped_early_string;
    void draw_separator_after_last_element;
    void stop_printing_after_this_many_elements;
};

struct Llvm_Options {
    Llvm_Bitcode_Optimization_Setting bitcode_optimization_setting;
    Llvm_Machine_Code_Optimization_Setting machine_code_optimization_setting;
    bool function_sections;
    void enable_tail_calls;
    void enable_loop_unrolling;
    void enable_slp_vectorization;
    void enable_loop_vectorization;
    void preserve_debug_info;
    void merge_functions;
    void disable_inlining;
    void disable_mem2reg;
    void enable_split_modules;
    void output_bitcode_before_optimizations;
    void output_llvm_ir_before_optimizations;
    void output_bitcode;
    void output_llvm_ir;
    char* target_system_triple;
    char* target_system_cpu;
    char* target_system_features;
    char** command_line;
};

struct Code_Compound_Declaration {
    Code_Comma_Separated_Arguments* comma_separated_assignment;
    Code_Declaration* declaration_properties;
    Code_Node* alignment_expression;
    Code_Note** notes;
    void operator_type;
};

struct BITMAPINFOHEADER {
    u32 biSize;
    s32 biWidth;
    s32 biHeight;
    u16 biPlanes;
    u16 biBitCount;
    u32 biCompression;
    u32 biSizeImage;
    s32 biXPelsPerMeter;
    s32 biYPelsPerMeter;
    u32 biClrUsed;
    u32 biClrImportant;
};

struct AnyVector2 {
    f32 x;
    f32 y;
};

struct World {
    void COLLISION_MARGIN;
    void count_joint_Constraint_Fitted_To_PageSize;
    void count_RigidBody_Fitted_To_PageSize;
    Soft_Body* soft_bodies[1];
    void bodies;
    void hashed_bodies;
    void joint_constraints;
    void hashed_joint_constraints;
    void VOLOR;
    u64 counter;
    VOLOR* points_to_draw[10];
    s64 points_to_draw_cursor;
};

struct MINIDUMP_CALLBACK_INFORMATION {
    MINIDUMP_CALLBACK_ROUTINE CallbackRoutine;
    void* CallbackParam;
};

struct Type_Info_Variant {
    char* name;
    Type_Info* variant_of;
    Type_Info_Variant_Flags variant_flags;
};

struct MSG {
    HWND hwnd;
    u32 message;
    WPARAM wParam;
    LPARAM lParam;
    s32 time;
    POINT pt;
    s32 lPrivate;
};

struct Code_Directive_Import {
    char* name;
    void flags;
    Provided_Import_Type import_type;
    Code_Procedure_Call* module_parameters_call;
    Code_Procedure_Call* program_parameters_call;
};

struct AnyMatrix {
    void IsMatrixFromMathModule;
};

struct Code_Directive_Code {
    Code_Node* expression;
    void code_flags;
};

struct STICKYKEYS {
    u32 cbSize;
    STICKYKEY_FLAGS dwFlags;
};

struct EXCEPTION_RECORD {
    u32 ExceptionCode;
    u32 ExceptionFlags;
    EXCEPTION_RECORD* ExceptionRecord;
    void* ExceptionAddress;
    u32 NumberParameters;
    u64* ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
};

struct ICONINFO {
    BOOL fIcon;
    u32 xHotspot;
    u32 yHotspot;
    HBITMAP hbmMask;
    HBITMAP hbmColor;
};

struct FormatFloat {
    void width;
    void trailing_width;
    void Zero_Removal;
    void zero_removal;
    void Mode;
    void mode;
    void thousand_separators;
    u8 thousand_separator_character;
    u8 decimal_separator_character;
    u8 exponent_character;
    void Positive_Number_Prefix;
    void positive_number_prefix;
};

struct Code_Directive_Modify {
    Code_Block* block;
};

struct Code_Cast {
    Code_Type_Instantiation* target_type;
    Code_Node* expression;
    void cast_flags;
};

struct Message_Debug_Dump {
    char* dump_text;
};

struct FILE_NOTIFY_INFORMATION {
    s32 NextEntryOffset;
    s32 Action;
    s32 FileNameLength;
    s16* FileName[1];
};

struct EXCEPTION_POINTERS {
    EXCEPTION_RECORD* ExceptionRecord;
    CONTEXT* ContextRecord;
};

struct FILETIME {
    u32 dwLowDateTime;
    u32 dwHighDateTime;
    u64 QuadPart;
};

struct SIZE {
    s32 cx;
    s32 cy;
};

struct Code_Placeholder {
};

struct Type_Info_Pointer {
    Type_Info* pointer_to;
};

struct Array_View_64 {
    s64 count;
    u8* data;
};

struct Bivector {
    f32* component[3];
};

struct Version_Info {
    s32 major;
    s32 minor;
    s32 micro;
};

struct OSVERSIONINFOA {
    u32 dwOSVersionInfoSize;
    u32 dwMajorVersion;
    u32 dwMinorVersion;
    u32 dwBuildNumber;
    u32 dwPlatformId;
    u8* szCSDVersion[128];
};

struct RECT {
};

struct RTL_CRITICAL_SECTION {
    RTL_CRITICAL_SECTION_DEBUG* DebugInfo;
    u32 LockCount;
    u32 RecursionCount;
    HANDLE OwningThread;
    HANDLE LockSemaphore;
    u64 SpinCount;
};

struct Code_Extract {
    Code_Node* from;
    s64 index;
};

struct Heap_Statistics {
    s64 sizecache;
    s64 spancache;
};

struct GUID {
    u32 Data1;
    u16 Data2;
    u16 Data3;
    u8* Data4[8];
};

struct SHFILEOPSTRUCTA {
    HWND hwnd;
    u32 wFunc;
    u8* pFrom;
    u8* pTo;
    FILEOP_FLAGS fFlags;
    BOOL fAnyOperationsAborted;
    void* hNameMappings;
    u8* lpszProgressTitle;
};

struct Code_Return {
    Code_Argument* arguments_unsorted;
    Code_Node** arguments_sorted;
    Flags return_flags;
    void Flags;
};

struct Code_Unary_Operator {
    void operator_type;
    Code_Node* subexpression;
};

struct Code_Directive_Add_Context {
    Code_Node* expression;
};

struct RAWHID {
    u32 dwSizeHid;
    u32 dwCount;
    u8* bRawData[1];
};

struct PROCESSOR_RELATIONSHIP {
    u8 Flags;
    u8 EfficiencyClass;
    u8* Reserved[20];
    u16 GroupCount;
    GROUP_AFFINITY GroupMask;
};

struct WNDCLASSEXA {
};

struct Code_Asm {
    void* b1;
    void** b2;
    u64* b3;
};

struct Memcpy_Map {
    Single_Copy* single_copies;
    void Single_Copy;
};

struct Typechecked {
    T* expression;
    Code_Node** subexpressions;
};

struct physics_coordinates {
    void forward;
    void left;
    void up;
    void back;
    void right;
    void down;
};

struct Global_Data_Info {
    u64 version_stamp;
    Global_Data_Segment_Info* segment_info;
};

struct PIXELFORMATDESCRIPTOR {
    s16 nSize;
    s16 nVersion;
    s32 dwFlags;
    u8 iPixelType;
    u8 cColorBits;
    u8 cRedBits;
    u8 cRedShift;
    u8 cGreenBits;
    u8 cGreenShift;
    u8 cBlueBits;
    u8 cBlueShift;
    u8 cAlphaBits;
    u8 cAlphaShift;
    u8 cAccumBits;
    u8 cAccumRedBits;
    u8 cAccumGreenBits;
    u8 cAccumBlueBits;
    u8 cAccumAlphaBits;
    u8 cDepthBits;
    u8 cStencilBits;
    u8 cAuxBuffers;
    u8 iLayerType;
    u8 bReserved;
    s32 dwLayerMask;
    s32 dwVisibleMask;
    s32 dwDamageMask;
};

struct Size_Class {
    u32 block_size;
    u16 block_count;
    u16 class_idx;
};

struct Code_Binary_Operator {
    void operator_type;
    Flags flags;
    Code_Node* left;
    Code_Node* right;
    void Flags;
};

struct Build_Options_During_Compile {
    void do_output;
    void write_added_strings;
    void append_executable_filename_extension;
    void interactive_bytecode_debugger;
    char** append_linker_arguments;
    char* output_executable_name;
    char* output_path;
};

struct Type_Info_Enum {
    char* name;
    Type_Info_Integer* internal_type;
    char** names;
    s64* values;
    Enum_Status_Flags status_flags;
    Enum_Type_Flags enum_type_flags;
};

struct Code_Struct {
    Code_Directive_Modify** modify_directives;
    Code_Block* block;
    Code_Block* arguments_block;
    Code_Block* constants_block;
    Code_Note** notes;
    Struct_Textual_Flags textual_flags;
    s32 alignment;
    Type_Info_Struct* defined_type;
};

struct Code_Directive_Poke_Name {
    Code_Struct* module_struct;
    char* name;
};

struct RAWKEYBOARD {
    u16 MakeCode;
    u16 Flags;
    u16 Reserved;
    u16 VKey;
    u32 Message;
    u32 ExtraInformation;
};

struct Code_Directive_Run {
    Code_Procedure_Header* procedure;
    void flags;
    char* assertion_string;
};

struct Source_Code_Range {
    char* fully_pathed_filename;
    s64 line_number_start;
    s64 line_number_end;
    s64 character_number_start;
    s64 character_number_end;
};

struct Type_Info_Struct {
    char* name;
    Type_Info_Struct_Member* parameters;
    Type_Info_Struct_Member* specified_parameters;
    Type_Info_Struct_Member* members;
    Struct_Status_Flags status_flags;
    Struct_Nontextual_Flags nontextual_flags;
    Struct_Textual_Flags textual_flags;
    Type_Info_Struct* polymorph_source_struct;
    void initializer;
    u8* constant_storage;
    char** notes;
};

struct Procedure_With_Data {
    void* proc;
    void* data;
};

struct FloatInt64 {
    u64 _u64;
    s64 _s64;
    f64 _float64;
};

struct Metaprogram_Plugin {
    Workspace workspace;
    void init;
    void before_intercept;
    void add_source;
    void message;
    void finish;
    void shutdown;
    void log_help;
    void communication_proc;
};

struct Bucket_Locator {
    u32 bucket_index;
    s32 slot_index;
};

struct Code_Expression_Query {
    void query_kind;
    Code_Node* expression_to_query;
};

struct COORD {
};

struct Code_Array_Literal_Info {
    Code_Type_Instantiation* element_type;
    Code_Node* alignment;
    Code_Node** array_members;
    void array_literal_flags;
};

struct Code_Directive_Scope {
    void scope_type;
};

struct Message_Phase {
    void phase;
    char* executable_name;
    void executable_write_failed;
    s32 linker_exit_code;
    s32 num_items_waiting_to_typecheck;
    char** compiler_generated_object_files;
    char** support_object_files;
    char** system_libraries;
    char** user_libraries;
};

struct Code_Procedure_Body {
    Code_Block* block;
    Code_Procedure_Header* header;
    void body_flags;
};

struct Calendar_Time {
    s32 year;
    s8 month_starting_at_0;
    s8 day_of_month_starting_at_0;
    s8 day_of_week_starting_at_0;
    s8 hour;
    s8 minute;
    s8 second;
    s16 millisecond;
    Time_Zone time_zone;
};

struct Code_Directive_Wildcard {
    s32 index;
};

struct Bytecode_Report {
    s64 num_calls_inlined;
    s64 num_calls_total;
    s64 num_instructions_inlined;
    s64 num_instructions_total;
};

struct GROUP_AFFINITY {
    u64 Mask;
    u16 Group;
    u16* Reserved[3];
};

struct String_Builder {
    void Buffer;
    void initialized;
    void failed;
    void subsequent_buffer_size;
    Allocator allocator;
    Buffer* current_buffer;
    u8* initial_bytes[STRING_BUILDER_BUFFER_SIZE];
};

struct IMAGEHLP_LINEW64 {
    u32 SizeOfStruct;
    void* Key;
    u32 LineNumber;
    u16* FileName;
    u64 Address;
};

struct Code_While {
    Code_Node* condition;
    Code_Block* block;
};

struct Build_Options {
    void Output_Type;
    void output_type;
    char* output_executable_name;
    char* output_path;
    char* intermediate_path;
    char* entry_point_name;
    char** compile_time_command_line;
    void append_executable_filename_extension;
    void use_custom_link_command;
    s32 temporary_storage_size;
    char** import_path;
    char** additional_linker_arguments;
    u64 user_data_u64;
    char* user_data_string;
    void* user_data_pointer;
    s32 user_data_pointer_size;
};

struct OPENFILENAME {
    u32 lStructSize;
    HWND hwndOwner;
    HINSTANCE hInstance;
    T* lpstrFilter;
    T* lpstrCustomFilter;
    u32 nMaxCustFilter;
    u32 nFilterIndex;
    T* lpstrFile;
    u32 nMaxFile;
    T* lpstrFileTitle;
    u32 nMaxFileTitle;
    T* lpstrInitialDir;
    T* lpstrTitle;
    u32 Flags;
    u16 nFileOffset;
    u16 nFileExtension;
    T* lpstrDefExt;
    LPARAM lCustData;
    void* lpfnHook;
    T* lpTemplateName;
    void* pvReserved;
    u32 dwReserved;
    u32 FlagsEx;
};

struct RAWINPUTDEVICE {
    u16 usUsagePage;
    u16 usUsage;
    s32 dwFlags;
    HWND hwndTarget;
};

struct MINIDUMP_CALLBACK_OUTPUT {
};

struct WIN32_FIND_DATAW {
    s32 dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD dwReserved0;
    DWORD dwReserved1;
    u16* cFileName[MAX_PATH];
    u16* cAlternateFileName[14];
};

struct CURSORINFO {
    DWORD cbSize;
    DWORD flags;
    HCURSOR hCursor;
    POINT ptScreenPos;
};

struct CACHE_RELATIONSHIP {
    u8 Level;
    u8 Associativity;
    u16 LineSize;
    u32 CacheSize;
    PROCESSOR_CACHE_TYPE Type;
    u8* Reserved[18];
    u16 GroupCount;
    GROUP_AFFINITY GroupMask;
};

struct Code_Enum {
    Code_Type_Instantiation* internal_type_inst;
    Type_Info* internal_type;
    Type_Info_Enum* external_type;
    Code_Block* block;
    Code_Note** notes;
    void marked_as_complete;
    void marked_as_specified;
    void is_flags;
};

struct Code_Type_Query {
    void query_kind;
    Code_Type_Instantiation* type_to_query;
};

struct Heap {
    void* lock;
    bool is_orphaned;
    Heap_Size_Class* size_class[SIZE_CLASS_COUNT];
    void* span_free_deferred;
    s64 full_span_count;
    Span* span_reserve;
    Span* span_reserve_master;
    u32 spans_reserved;
    s32 child_count;
    Heap* next_heap;
    Heap* next_orphan;
    s32 id;
    s32 finalize;
    Heap* master_heap;
    Span** full_span[SIZE_CLASS_COUNT];
    Span* large_huge_span;
};

struct Solver {
    void dt;
    void gravity;
    void iterations;
    u64 number_of_steps_executed_so_far;
};

struct Message_Failed_Import {
    void status;
    char* host_module_name;
    char* target_module_name;
    Code_Directive_Import* import_code;
};

struct Matrix6 {
    Vector6* v[6];
    f32** coef[6];
    f32* floats[36];
};

struct Code_Directive_Bytes {
    Code_Node* expression;
};

struct ADDRESS64 {
    u64 Offset;
    u16 Segment;
    ADDRESS_MODE Mode;
};

struct Log_Info {
    u64 source_identifier;
    Source_Code_Location location;
    Log_Flags common_flags;
    u32 user_flags;
    Log_Section* section;
};

struct MINIDUMP_CALLBACK_INPUT {
    u32 ProcessId;
    HANDLE ProcessHandle;
    MINIDUMP_CALLBACK_TYPE CallbackType;
};

struct MINIDUMP_EXCEPTION_INFORMATION64 {
    DWORD ThreadId;
    u64 ExceptionRecord;
    u64 ContextRecord;
    BOOL ClientPointers;
};

struct Bucket_Array {
    s64 count;
    Allocator allocator;
    void My_Bucket;
    My_Bucket** all_buckets;
    My_Bucket** unfull_buckets;
};

struct AABB {
    Vector3 min;
    Vector3 max;
    Vector3 extents;
    Vector3 center;
    Vector3 half_extents;
};

struct Run_Directive_Report {
    void reported;
    void Record;
    Record* records;
};

struct Code_Context {
};

struct ICONINFOEXW {
    u32 cbSize;
    BOOL fIcon;
    u32 xHotspot;
    u32 yHotspot;
    HBITMAP hbmMask;
    HBITMAP hbmColor;
    u16 wResID;
    u16* szModName[MAX_PATH];
    u16* szResName[MAX_PATH];
};

struct CONTEXT {
    u64 P1Home;
    u64 P2Home;
    u64 P3Home;
    u64 P4Home;
    u64 P5Home;
    u64 P6Home;
    u32 ContextFlags;
    u32 MxCsr;
    u16 SegCs;
    u16 SegDs;
    u16 SegEs;
    u16 SegFs;
    u16 SegGs;
    u16 SegSs;
    u32 EFlags;
    u64 Dr0;
    u64 Dr1;
    u64 Dr2;
    u64 Dr3;
    u64 Dr6;
    u64 Dr7;
    u64 Rax;
    u64 Rcx;
    u64 Rdx;
    u64 Rbx;
    u64 Rsp;
    u64 Rbp;
    u64 Rsi;
    u64 Rdi;
    u64 R8;
    u64 R9;
    u64 R10;
    u64 R11;
    u64 R12;
    u64 R13;
    u64 R14;
    u64 R15;
    u64 Rip;
    M128A* VectorRegister[26];
    u64 VectorControl;
    u64 DebugControl;
    u64 LastBranchToRip;
    u64 LastBranchFromRip;
    u64 LastExceptionToRip;
    u64 LastExceptionFromRip;
};

struct SIMD_Array {
    type* data[count];
};

struct Runtime_Info {
    Type_Info** type_table;
    Global_Data_Info* global_data_info;
};

struct Vector3 {
    Vector2 xy;
    Vector2 yz;
    f32* component[3];
};

struct Code_Block {
    Code_Block* parent;
    void block_type;
    void block_flags;
    Code_Struct* belongs_to_struct;
    Code_Scope_Entry** members;
    Code_Node** statements;
    Code_Node* owning_statement;
};

struct RAWINPUT {
    RAWINPUTHEADER header;
    void data;
};

struct STARTUPINFOA {
    s32 cb;
    u8* lpReserved;
    u8* lpDesktop;
    u8* lpTitle;
    s32 dwX;
    s32 dwY;
    s32 dwXSize;
    s32 dwYSize;
    s32 dwXCountChars;
    s32 dwYCountChars;
    s32 dwFillAttribute;
    s32 dwFlags;
    s16 wShowWindow;
    s16 cbReserved2;
    u8* lpReserved2;
    HANDLE hStdInput;
    HANDLE hStdOutput;
    HANDLE hStdError;
};

struct SHFILEOPSTRUCTW {
    HWND hwnd;
    u32 wFunc;
    u16* pFrom;
    u16* pTo;
    FILEOP_FLAGS fFlags;
    BOOL fAnyOperationsAborted;
    void* hNameMappings;
    u16* lpszProgressTitle;
};

struct Allocator {
    Allocator_Proc proc;
    void* data;
};

struct Rotor {
    f32 s;
    Bivector b;
};

struct Code_Resolved_Overload {
    Code_Node* result;
    Code_Node* source_expression;
};

struct SYMBOL_INFO {
    u32 SizeOfStruct;
    u32 TypeIndex;
    u64* Reserved[2];
    u32 Index;
    u32 Size;
    u64 ModBase;
    u32 Flags;
    u64 Value;
    u64 Address;
    u32 Register;
    u32 Scope;
    u32 Tag;
    u32 NameLen;
    u32 MaxNameLen;
    u8* Name[1];
};

struct Code_Procedure_Header {
    Code_Block* constants_block;
    Code_Declaration** arguments;
    Code_Declaration** returns;
    Code_Using** parameter_usings;
    char* name;
    char* foreign_function_name;
    Code_Ident* library_identifier;
    char* deprecation_string;
    Code_Procedure_Header* polymorph_source_header;
    Code_Directive_Modify** modify_directives;
    Code_Procedure_Body* body_or_null;
    void procedure_flags;
    Code_Note** notes;
};

struct Code_Scope_Entry {
    char* name;
    Code_Declaration* import_target;
};

struct FLASHWINFO {
    u32 cbSize;
    HWND hwnd;
    FLASHW dwFlags;
    u32 uCount;
    u32 dwTimeout;
};

struct Code_Make_Varargs {
    Type_Info* element_type;
    Code_Node** expressions;
    bool is_for_non_native_calling_convention;
};

struct Type_Info_Struct_Member {
    char* name;
    Type_Info* type;
    s64 offset_in_bytes;
    Flags flags;
    char** notes;
    s64 offset_into_constant_storage;
    void Flags;
};

struct TIMECAPS {
    u32 wPeriodMin;
    u32 wPeriodMax;
};

struct Matrix_RC {
    void* v[ROW];
    type** coef[ROW];
    type* floats[0];
    void Row_Type;
    void Column_Type;
    void IsMatrixFromMathModule;
    bool IS_SQUARED;
};

struct Temporary_Storage_State {
    void* top_overflow_page;
    s64 current_page_bytes_occupied;
    s64 total_bytes_occupied;
};

struct IUnknown_VTable {
    void QueryInterface;
    void AddRef;
    void Release;
};

struct Quaternion {
    void w;
    f32* component[4];
    Vector3 xyz;
};

struct Global_Data_Segment_Info {
    void segment_tag;
    u8* data;
};

struct KDHELP64 {
    u64 Thread;
    u32 ThCallbackStack;
    u32 ThCallbackBStore;
    u32 NextCallback;
    u32 FramePointer;
    u64 KiCallUserMode;
    u64 KeUserCallbackDispatcher;
    u64 SystemRangeStart;
    u64 KiUserExceptionDispatcher;
    u64 StackBase;
    u64 StackLimit;
    u64* Reserved[5];
};

struct Code_Comma_Separated_Arguments {
    Code_Comma_Separated_Argument* arguments;
};

struct LIST_ENTRY {
    LIST_ENTRY* Flink;
    LIST_ENTRY* Blink;
};

struct RTL_CRITICAL_SECTION_DEBUG {
    u16 Type;
    u16 CreatorBackTraceIndex;
    RTL_CRITICAL_SECTION* CriticalSection;
    LIST_ENTRY ProcessLocksList;
    u32 EntryCount;
    u32 ContentionCount;
    u32 Flags;
    u16 CreatorBackTraceIndexHigh;
    u16 SpareWORD;
};

struct Code_Case {
    Code_Node* condition;
    Code_Block* then_block;
    Code_If* owning_if;
    void marked_as_fallthrough;
};

struct LUID {
    u32 LowPart;
    s32 HighPart;
};

struct HexDouble {
    u64 _u64;
    f64 _float64;
};

struct Matrix4x3 {
    Vector4* v[3];
    f32** coef[3];
    f32* floats[12];
    void Row_Type;
    void Column_Type;
    void IsMatrixFromMathModule;
};

struct Data_Segment {
};

struct Code_Directive_Procedure_Name {
    Code_Node* argument;
};

struct STARTUPINFOW {
    s32 cb;
    u16* lpReserved;
    u16* lpDesktop;
    u16* lpTitle;
    s32 dwX;
    s32 dwY;
    s32 dwXSize;
    s32 dwYSize;
    s32 dwXCountChars;
    s32 dwYCountChars;
    s32 dwFillAttribute;
    s32 dwFlags;
    s16 wShowWindow;
    s16 cbReserved2;
    u8* lpReserved2;
    HANDLE hStdInput;
    HANDLE hStdOutput;
    HANDLE hStdError;
};


// Procedures
Workspace get_current_workspace();
void memcpy(void* dest, void* source, s64 count);
s16 memcmp(void* a, void* b, s64 count);
void memset(void* dest, u8 value, s64 count);
char* maybe_insert_DEBUG();
void log_TODO( loc);
void create_solver_and_world();
void simulate();
Vector3 l2w(Vector3 position, Quaternion Aori, Vector3 local_point);
Vector3 l2w_rotate_only(Vector3 _, Quaternion Aori, Vector3 local_point);
Vector3 w2l(Vector3 position, Quaternion orientation, Vector3 world_point);
Vector3 w2l_rotate_only(Vector3 _, Quaternion orientation, Vector3 world_point);
bool get_C_and_normal(Vector3 error);
f32 get_lambda(f32 dt, f32 w, f32 C);
f32 get_lambda(f32 dt, f32 w, f32 C, f32 compliance);
f32 get_lambda(f32 dt, f32 w, f32 C, f32 compliance, f32 old_lambda);
bool get_total_effective_mass_local(Body* A, Body* B, Vector3 normal);
bool get_total_effective_mass_world(Body* A, Body* B, Vector3 normal, Vector3 point_of_application_A, Vector3 point_of_application_B);
f32 get_effective_mass_angular_only(Body body, Vector3 world_lever);
f32 get_effective_mass(Body* body, Vector3 normalized_world_force, Vector3 world_attach_position);
f32 apply_world_position_correction(Body* A, Body* B, f32 dt, f32 compliance, Vector3 correction, Vector3 attach_position_A, Vector3 attach_position_B);
f32 apply_world_velocity_correction(Body* A, Body* B, f32 dt, f32 compliance, Vector3 correction, Vector3 attach_position_A, Vector3 attach_position_B);
Vector3 get_world_linear_velocity_correction(Body body, Vector3 correction_force);
Vector3 get_world_angular_velocity_correction(Body body, Vector3 correction_force, Vector3 world_point_of_application);
Vector3 get_delta_angular_from_torque(Vector3 inv_local_moment_of_inertia, Quaternion orientation, Vector3 correction_torque);
Vector3 get_delta_angular_from_torque(Body body, Vector3 correction_torque);
f32 apply_local_cm_position_correction(Body* A, Body* B, f32 dt, f32 compliance, Vector3 angular_error);
f32 apply_local_cm_angular_velocity_correction(Body* A, Body* B, f32 dt, f32 compliance, Vector3 angular_error);
Quaternion get_stable_delta_orientation(Vector3 delta_angular, Quaternion orientation);
void apply_local_linear_position_correction(Body* A, Vector3 correction, Vector3 unused_world_attach_point);
Vector3 get_world_linear_position_correction(f32 inv_mass, Vector3 correction_force, Vector3 unused_world_attach_point);
Vector3 get_world_linear_position_correction(Body body, Vector3 correction_force, Vector3 unused_world_attach_point);
Quaternion get_angular_delta(Body body, Vector3 correction_force, Vector3 point_of_application);
Quaternion get_world_angular_position_correction(Body body, Vector3 correction_force, Vector3 point_of_application);
u64 combine_hashes(u64 a, u64 b);
void doHook(Body* body, Vector3 world_attach_point, f32 target_length,  linear_compliance, s64 identifier,  loc);
void doHookDontUpdate(Body* body, Vector3 world_attach_point, f32 target_length,  linear_compliance, s64 identifier,  loc);
void doWeld(Body* body, Vector3 world_attach_point, Vector3 weld_relative_axis, f32 rest_angle_radians, f32 target_length, s64 identifier,  loc);
Quaternion quaternion_from_axes_to_axes(Vector3 from_x, Vector3 from_y, Vector3 from_z, Vector3 to_x, Vector3 to_y, Vector3 to_z);
Quaternion quaternion_from_basis(Vector3 forward, Vector3 left, Vector3 up);
void doDoor(Body* body, Vector3 world_hinge_attach_position, Vector3 world_hinge_axis, Vector3 world_door_plane_direction, f32 min_angle_radians, f32 max_angle_radians, bool reverse_opening_direction, s64 identifier,  loc);
Body* doBall(Matrix4* transform, f32 radius, f32 mass, s64 identifier,  loc);
Body* create_ball(Vector3 position, f32 radius, f32 mass);
Joint_Constraint* create_joint_constraint(Body* A, Body* B);
Body* create_body();
Joint_Constraint* find_or_create_joint_constraint(u64 hash, Body* A, Body* B);
Body* find_or_create_ball(u64 hash, Vector3 ball_position, f32 radius, f32 mass);
void initHingeJoint(Joint_Constraint* joint, f32 swingMin, f32 swingMax, f32 hasTargetAngle, f32 targetAngle, f32 compliance, f32 damping);
void initServo(Joint_Constraint* joint, f32 swingMin, f32 swingMax);
void initMotor(Joint_Constraint* joint, Vector3 velocity);
void initBallJoint(Joint_Constraint* joint, f32 swingMax, f32 twistMin, f32 twistMax, f32 damping);
void initPrismaticJoint(Joint_Constraint* joint, f32 distanceMin, f32 distanceMax, f32 twistMin, f32 twistMax, f32 hasTarget, f32 target_length, f32 targetCompliance, f32 damping);
void initCylinderJoint(Joint_Constraint* joint, f32 distanceMin, f32 distanceMax, f32 twistMin, f32 twistMax, f32 hasTargetDistance, f32 restDistance, f32 compliance, f32 damping);
void recalculate_world_attach_pos_and_ori(Joint_Constraint* joint);
void solve(Joint_Constraint* joint, f32 dt);
void mostly_shared_presolve_default_cb(Joint_Constraint* joint, f32 dt);
void solve_position_for_distance_constraint_cb(Joint_Constraint* joint, f32 dt);
void solve_position_for_one_way_distance_constraint_cb(Joint_Constraint* joint, f32 dt);
void solve_position_for_fixed_constraint_cb(Joint_Constraint* joint, f32 dt);
void solve_orientation_for_fixed_constraint_cb(Joint_Constraint* joint, f32 dt);
void solve_orientation_for_door_constraint_cb(Joint_Constraint* joint, f32 dt);
void solve_orientation_for_door_constraint_cbIterus(Joint_Constraint* joint, f32 dt);
void solve_orientation_for_door_constraint_cbBAD(Joint_Constraint* joint, f32 dt);
Vector3 get_velocity_at_position(Body* body, Vector3 position);
void default_linear_damping_cb(Joint_Constraint* joint, f32 dt);
void default_angular_damping_cb(Joint_Constraint* joint, f32 dt);
void max_angular_damping_cb(Joint_Constraint* joint, f32 dt);
void hinge_angular_damping_cb(Joint_Constraint* joint, f32 dt);
f32 getAngle(Joint_Constraint* joint, Vector3 n, Vector3 a, Vector3 b);
void limitAngle(Joint_Constraint* joint, f32 dt, Vector3 n, Vector3 axis_A, Vector3 axis_B, f32 minAngle, f32 maxAngle, f32 compliance);
void limitAngleBAD(Joint_Constraint* joint, f32 dt, Vector3 n, Vector3 axis_A, Vector3 axis_B, f32 minAngle, f32 maxAngle, f32 compliance);
void maybe_apply_angle_limit(Joint_Constraint* joint, f32 dt, Vector3 n, Vector3 axis_A, Vector3 axis_B, f32 minAngle, f32 maxAngle, f32 compliance);
void init(Soft_Body* this, f32 edgeCompliance, f32 volCompliance);
void vecSetZero(f32* to_write, s64 to_write_idx);
void vecCopy(f32* to_write, s64 to_write_idx, f32* to_read, s64 to_read_idx);
f32 vecDot(f32* a, s64 a_idx, f32* b, s64 b_idx);
void vecSetDiff(f32* to_write, s64 to_write_idx, f32* to_add, s64 to_add_idx, f32* to_substract, s64 to_substract_idx, f32 scale_factor);
f32 getTetVolume2(Soft_Body* this, s64 idx);
f32 getTetVolume(Soft_Body* this, s64 idx);
f32 vecDistSquared(f32* positons_left, s64 anr_i, f32* positons_right, s64 bnr_i);
void initPhysics(Soft_Body* this);
void wide_add_broadcast_scaled(s64 idx, f32* to_write, Vector3 to_broadcast, f32 scale_factor);
void wide_add_scaled(s64 idx, f32* to_write, f32* to_read, f32 scale_factor);
void wide_add(s64 idx, f32* to_write, f32* to_read);
void wide_assign(s64 idx, f32* to_write, f32* to_read);
void wide_assign_scaled(s64 idx, f32* to_write, f32* to_read, f32 scale_factor);
void wide_assign_broadcast_scaled(s64 idx, f32* to_write, Vector3 to_broadcast, f32 scale_factor);
void preSolve(Soft_Body* this, f32 dt, Vector3 gravity);
void solve(Soft_Body* this, f32 dt);
void postSolve(Soft_Body* this, f32 dt);
void squash(Soft_Body* this);
void translate(Soft_Body* this, Vector3 translation);
f32 vecLengthSquared(f32* to_write, s64 to_write_idx);
void solveEdges(Soft_Body* this, f32 compliance, f32 dt);
void vecSetCross(f32* to_write, s64 to_write_idx, f32* left_arg, s64 left_arg_idx, f32* right_arg, s64 right_arg_idx);
void vecScale(f32* to_write, s64 to_write_idx, f32 scale_factor);
void vecAdd(f32* to_write, s64 to_write_idx, f32* to_read, s64 to_read_idx, f32 scale_factor);
void solveVolumes(Soft_Body* this, f32 compliance, f32 dt);
void solve_position(Joint_Constraint* joint, f32 dt);
void solve_orientation(Joint_Constraint* joint, f32 dt);
bool find_nearest_ball(Vector3 position, f32 radius);
void simplex_add(Simplest_Geometric_Shape* simplex, Vector3 point);
bool is_valid(s64 a);
bool is_valid(f32 a);
bool is_valid(f64 a);
bool is_valid(Quaternion a);
s16 abs(s16 x);
s8 abs(s8 x);
char* insert_multiplciations_rc(s64 ROW, s64 COL);
char* insert_12_13_transpose(s64 ROW, s64 COL);
char* maybe_insert_DEBUG();
Vector3 get_normal_from_normal(Vector3 n);
Quaternion shortest_arc(Vector3 prenormalized_a, Vector3 prenormalized_b);
f32 cross_dot(Vector3 a, Vector3 b);
Vector3 rotate_onto_plane(Vector3 point, Vector3 plane_normal, f32 plane_distance);
Matrix2 outer(Vector2 a, Vector2 b);
Matrix3 outer(Vector3 a, Vector3 b);
Matrix6 outer(Vector6 a, Vector6 b);
Matrix3 force_positive(Matrix3 a);
Matrix6 force_positive(Matrix6 a);
Vector6 force_positive(Vector6 a);
f32 axis_abs_trace(Quaternion a);
f32 trace(Vector6 a);
f32 trace(Matrix6 a);
Matrix2 Abs(Matrix2 a);
Vector2 Column(Matrix2 m, s64 i);
Vector3 Column(Matrix3 m, s64 i);
Vector6 Column(Matrix6 m, s64 i);
Matrix3 make_diagonal_matrix(f32 m00, f32 m11, f32 m22);
Matrix3 make_diagonal_matrix_linear_angular(f32 m00, f32 m11, f32 m22, f32 m33, f32 m44, f32 m55);
Matrix6 make_diagonal_matrix(f32 m00, f32 m11, f32 m22, f32 m33, f32 m44, f32 m55);
f32 length(Vector6 a);
Vector3 Solve(Matrix3 a, Vector3 b);
bool is_symmetric(Matrix3 a);
bool is_symmetric(Matrix6 a);
Vector3 get_scale(Matrix4 mat);
Vector3 koda_decompose_transform(Matrix4 matrix);
Vector3 get_translation(Matrix4 matrix);
Vector3 transform_plane(Vector3 in_plane_normal, f32 in_plane_distance, Matrix4 mat);
Vector6 Solve(Matrix6 a, Vector6 b);
Matrix6 Symmetrize(Matrix6 m);
Matrix3 compute_joint_angular_hessian_block(Vector3 world_axis, Vector3 lever_arm);
Vector6 make_Vector6(Vector3 linear, Vector3 angular);
Vector3 to_Vector3_linear(Vector6 v);
Vector3 to_Vector3_angular(Vector6 v);
Matrix6 make_Matrix6(Matrix3 M_linear, Matrix3 M_angular);
Matrix6 *(Matrix6 a, f32 s);
Matrix6 +(Matrix6 a, Matrix6 b);
Vector6 *(Matrix6 a, Vector6 v);
Vector6 *(Vector6 a, f32 b);
Vector6 *(Vector6 a, f64 b);
Vector6 +(Vector6 a, Vector6 b);
s64 next_power_of_two(s64 x);
char** get_command_line_arguments();
bool assert_helper( message, Any* args,  loc);
void* alloc(s64 size);
void free(void* memory);
void* realloc(void* memory, s64 size, s64 old_size);
char* alloc_string(s64 count);
char* talloc_string(s64 count);
void free(char* s);
void* talloc(s64 size);
void* temporary_alloc(s64 size);
Temporary_Storage_State get_temporary_storage_mark();
void set_temporary_storage_mark(Temporary_Storage_State state,  loc);
void reset_temporary_storage();
s64 align_forward(s64 orig_size, s64 alignment);
f64 seconds_since_init();
void init_get_seconds();
void __element_duplicate(u8* start, s64 num_elements, s64 size);
void write_nonnegative_number(u64 n,  base,  to_standard_error);
void write_number(s64 n,  base,  to_standard_error);
bool runtime_support_assertion_failed(Source_Code_Location loc, char* message);
void runtime_support_default_logger(char* message, void* data, Log_Info info);
s64 c_style_strlen(u8* str);
char* to_string(u8* c_string);
void __array_bounds_check_fail(s64 index, s64 limit, s64 line_number, u8* filename);
void __cast_bounds_check_fail(s64 pre_value, u32 pre_flags, s64 post_value, u32 post_flags, u8 fatal, s64 line_number, u8* filename);
void __null_pointer_check_fail(s64 index, s64 line_number, u8* filename);
void __arithmetic_overflow(s64 left, s64 right, u16 type_code, s64 line_number, u8* filename);
void write_string_unsynchronized(char* s,  to_standard_error);
void write_string(char* s,  to_standard_error);
void write_strings(char** strings,  to_standard_error);
void write_loc(Source_Code_Location loc,  to_standard_error);
void my_panic();
void __panic_due_to_runtime_call_of_compile_time_procedure(s64 line_number, u8* filename);
void __instrumentation_first();
void __instrumentation_second();
void compile_time_debug_break();
void debug_break();
void set_initial_data(Temporary_Storage* ts, s64 count, u8* data);
void init_synchronization();
char* to_string(u8* s, s64 length);
char* to_string(u8* c_string);
u8* to_c_string(char* s);
u8 to_upper(u8 c);
u8 to_lower(u8 c);
bool is_alpha(u8 c);
bool is_digit(u8 c);
bool is_alnum(u8 c);
bool is_space(u8 c);
bool is_print(u8 c);
void advance(char** s, s64 amount);
char* advance(char* s, s64 amount);
u8* temp_c_string(char* s);
char* copy_temporary_string(char* s);
char* copy_string(char* s);
s64 to_integer(char* s);
char* eat_spaces(char* _s);
void init_string_builder(String_Builder* builder,  buffer_size);
void free_buffers(String_Builder* builder);
void reset(String_Builder* builder);
void* ensure_contiguous_space(String_Builder* builder, s64 bytes);
u8* ensure_contiguous_space_and_return_available_range(String_Builder* builder,  minimum_bytes);
void advance_through_ensured_space(String_Builder* builder, s64 bytes);
void append(String_Builder* builder, u8* s, s64 length);
void append(String_Builder* builder, char* s);
void append(String_Builder* builder, u8 byte);
s64 builder_string_length(String_Builder* builder);
char* builder_to_string(String_Builder* builder,  extra_bytes_to_prepend,  do_reset);
s64 write_builder(String_Builder* builder,  do_reset,  to_standard_error);
bool consume_u8_and_length(char** input, u8* s, s64 length);
void* get_current_buffer(String_Builder* builder);
void* get_base_buffer(String_Builder* builder);
u8* get_buffer_data(void* buffer);
bool expand(String_Builder* builder);
void append_and_steal_buffers(String_Builder* builder, String_Builder* steal_from);
s64 stb_print_float(String_Builder* builder, FormatFloat format);
void COPYFP(void* dest, void* src);
f64 ddmult_high(f64 oh, f64 ol, f64 xh, f64 yh);
s64 ddtoS64(f64 xh, f64 xl);
f64 ddrenorm(f64 oh, f64 ol);
f64 ddmult_low(f64 ol, f64 xh, f64 xl, f64 yh, f64 yl);
f64 ddmult_low_small(f64 ol, f64 xh, f64 yl);
void raise_to_power10(f64* ohi, f64* olo, f64 d, s32 power);
bool real_to_str(u8** start, s64* len, u8* out, s64* decimal_pos, f64 value, u32 frac_digits);
s64 abs(s64 x);
s32 abs(s32 x);
bool is_nan_is_inf(f64 x);
bool isnan(f64 x);
bool isinf(f64 x);
bool is_finite(f64 x);
bool is_nan_is_inf(f32 x);
bool isnan(f32 x);
bool isinf(f32 x);
bool is_finite(f32 x);
f64 abs(f64 x);
f32 abs(f32 x);
f64 fmod_cycling(f64 x, f64 y);
f32 fmod_cycling(f32 x, f32 divisor);
f32 tan(f32 theta);
f32 acos(f32 theta);
f32 asin(f32 theta);
f32 sqrt(f32 x);
f32 pow(f32 x, f32 power);
f32 exp(f32 x);
f32 log(f32 x);
f32 saturate(f32 f);
f64 saturate(f64 f);
f32 half_to_float(u16 h);
f32 dot_product(Vector2 a, Vector2 b);
f32 dot_product(Vector3 a, Vector3 b);
f32 dot_product(Vector4 a, Vector4 b);
f32 dot_product(Quaternion a, Quaternion b);
f32 length(Vector2 a);
f32 length(Vector3 a);
f32 length(Vector4 a);
f32 length(Quaternion a);
f32 length_squared(Vector2 a);
f32 length_squared(Vector3 a);
f32 length_squared(Vector4 a);
Vector2 make_vector2(f32 x);
Vector3 make_vector3(f32 x);
Vector3 make_vector3(f32* c);
Vector3 make_vector3(Vector2 v, f32 z);
Vector4 make_vector4(f32 x);
Vector4 make_vector4(Vector2 v, f32 z, f32 w);
Vector4 make_vector4(Vector3 v, f32 w);
Vector2 xy(f32 x, f32 y);
Vector2 xy(f32 x);
Vector3 xyz(f32 x, f32 y, f32 z);
Vector3 xyz(f32 x);
Vector3 xyz(f32* c);
Vector3 xyz(Vector2 v, f32 z);
Vector4 xyzw(f32 x, f32 y, f32 z, f32 w);
Vector4 xyzw(f32 x);
Vector4 xyzw(Vector2 v, f32 z, f32 w);
Vector4 xyzw(Vector3 v, f32 w);
f32 normalize_or_identity(Quaternion* q);
Vector2 abs(Vector2 v);
Vector3 abs(Vector3 v);
Vector4 abs(Vector4 v);
Vector2 min(Vector2 v1, Vector2 v2);
Vector3 min(Vector3 v1, Vector3 v2);
Vector4 min(Vector4 v1, Vector4 v2);
Vector2 max(Vector2 v1, Vector2 v2);
Vector3 max(Vector3 v1, Vector3 v2);
Vector4 max(Vector4 v1, Vector4 v2);
f32 lerp(f32 a, f32 b, f32 t);
f64 lerp(f64 a, f64 b, f64 t);
Quaternion lerp(Quaternion a, Quaternion b, f32 t);
Vector2 lerp(Vector2 a, Vector2 b, f32 t);
Vector3 lerp(Vector3 a, Vector3 b, f32 t);
Vector4 lerp(Vector4 a, Vector4 b, f32 t);
Quaternion nlerp(Quaternion p0, Quaternion p1, f32 fraction);
Quaternion slerp(Quaternion start, Quaternion end, f32 t);
Vector2 multiply(Vector2 v, f32 f);
Vector3 multiply(Vector3 v, f32 f);
f32 distance(Vector4 a, Vector4 b);
f32 distance(Vector3 a, Vector3 b);
f32 distance_squared(Vector3 a, Vector3 b);
f32 distance(Vector2 a, Vector2 b);
f32 distance_squared(Vector2 a, Vector2 b);
Vector3 unit_vector(Vector3 v);
Vector2 unit_vector(Vector2 v);
void rotate(Vector2* v, f32 theta);
Vector2 rotate(Vector2 v, f32 theta);
Vector3 cross_product(Vector3 a, Vector3 b);
Vector3 rotate(Vector3 v, Quaternion q);
void rotate(Vector3* v, Quaternion q);
Vector2 +(Vector2 a, Vector2 b);
Vector2 -(Vector2 a, Vector2 b);
Vector2 -(Vector2 a);
Vector2 *(Vector2 a, Vector2 b);
Vector2 *(Vector2 a, f32 k);
Vector2 /(Vector2 a, Vector2 b);
Vector2 /(Vector2 a, f32 k);
Vector2 /(f32 k, Vector2 a);
bool ==(Vector2 a, Vector2 b);
Vector2 saturate(Vector2 a);
Vector3 +(Vector3 a, Vector3 b);
Vector3 -(Vector3 a, Vector3 b);
Vector3 -(Vector3 a);
Vector3 *(Vector3 a, Vector3 b);
Vector3 *(Vector3 a, f32 k);
Vector3 *(Vector3 a, f64 k);
Vector3 /(Vector3 a, Vector3 b);
Vector3 /(Vector3 a, f32 k);
Vector3 /(f32 k, Vector3 a);
bool ==(Vector3 a, Vector3 b);
Vector3 saturate(Vector3 a);
Vector4 +(Vector4 a, Vector4 b);
Vector4 -(Vector4 a, Vector4 b);
Vector4 *(Vector4 a, Vector4 b);
Vector4 *(Vector4 a, f32 k);
Vector4 /(Vector4 a, Vector4 b);
Vector4 /(Vector4 a, f32 k);
Vector4 /(f32 k, Vector4 a);
bool ==(Vector4 a, Vector4 b);
Vector4 saturate(Vector4 a);
Quaternion +(Quaternion a, Quaternion b);
Quaternion *(Quaternion a, f32 k);
Quaternion -(Quaternion a, Quaternion b);
bool ==(Quaternion a, Quaternion b);
Quaternion -(Quaternion a);
void set_from_axis_and_angle(Quaternion* q, Vector3 v, f32 theta);
void set_from_axis_and_angle(Quaternion* q, f32 x, f32 y, f32 z, f32 theta);
f64 get_axis_and_angle(Quaternion q);
Quaternion conjugate(Quaternion q);
Quaternion *(Quaternion m, Quaternion a);
Vector3 make_an_orthonormal_basis(Vector3 x_axis);
Vector3 make_an_orthonormal_basis(Vector3 x_axis, Vector3 approximate_axis);
f32 string_to_float(char* arg);
f64 string_to_float64(char* _s);
f64 multiply_and_convert_to_float(u64 m, u32 bot, s32 bexp, s32 i, s32 neg);
u32 MUL_96(u32 n2, u32 n1, u32 n0, s32 bexp, s32 i);
u32 NORMALIZE(u32 n2, u32 n1, u32 n0, s32 bexp, u64 x2, u64 x1, u64 x0, s32 size);
s32 clz64(u64 x);
s32 clz32(u32 x);
u64 multiply_64bits_with_overflow(u64 a, u64 b);
bool ==(S128 a, S128 b);
bool ==(U128 a, U128 b);
bool !(S128 a);
bool !(U128 a);
S128 +(S128 a, S128 b);
S128 -(S128 a, S128 b);
U128 -(U128 a, U128 b);
S128 -(S128 a);
S128 <<(S128 a, u8 x);
U128 <<(U128 a, u8 x);
S128 >>(S128 a, u8 x);
U128 >>(U128 a, u8 x);
S128 logical_shift_right(S128 a, u8 x);
U128 /(U128 dividend, U128 divisor);
S128 /(S128 dividend, S128 divisor);
S128 /(S128 a, s64 factor);
S128 signed_divide_with_remainder(S128 dividend, S128 divisor);
U128 unsigned_divide_with_remainder(U128 u, U128 v);
u64 unsigned_divide_with_remainder_128_64_no_asm(U128 num, u64 den);
u8 count_leading_zero_bits(u64 x);
S128 *(S128 _a, S128 _b);
U128 *(U128 _a, U128 _b);
S128 *(S128 a, s64 factor);
bool <(S128 a, S128 b);
bool <(U128 a, U128 b);
bool <=(S128 a, S128 b);
bool >(S128 a, S128 b);
bool >=(S128 a, S128 b);
bool <=(U128 a, U128 b);
bool >(U128 a, U128 b);
bool >=(U128 a, U128 b);
U128 *(U128 a, s64 b);
U128 *(U128 a, u64 b);
U128 +(U128 a, U128 b);
U128 +(U128 a, u64 b);
Plane3 make_plane(f32 a, f32 b, f32 c, f32 d);
Plane3 make_plane(Vector3 v, f32 d);
Plane3 make_plane(Vector3 v, Vector3 x);
Plane3 plane_from_point_and_normal(Vector3 point, Vector3 normal);
Plane3 make_plane(Vector4 v);
Vector3 get_normal(Plane3 p);
Plane3 normalize(Plane3 p);
Plane3 normalized_plane_from_points(Vector3 p0, Vector3 p1, Vector3 p2);
f32 plane_dot(Plane3 plane, Vector3 v);
Plane3 -(Plane3 p);
char* calendar_to_string(Calendar_Time ct);
char* calendar_to_iso_string(Calendar_Time ct);
FormatInt formatInt(Any value,  base,  minimum_digits, u8 padding, u16 digits_per_comma,  comma_string);
FormatStruct formatStruct(Any value,  use_long_form_if_more_than_this_many_members,  use_newlines_if_long_form);
s64 get_s64_from_void_pointer(void* pointer, s64 size_in_bytes);
u64 get_u64_from_void_pointer(void* pointer, s64 size_in_bytes);
void print_u64_base_n(String_Builder* builder, u64 v, FormatInt format);
void print_float(String_Builder* builder, FormatFloat format);
void print_integer(String_Builder* builder, FormatInt format);
void print_character(u8 _c);
s64 print(char* format_string, Any* args,  to_standard_error);
char* sprint(char* format_string, Any* args);
char* tprint(char* format_string, Any* args);
void append_indentation(String_Builder* builder, FormatStruct* format);
void print_item_to_builder(String_Builder* builder, Any item,  inside_struct_or_array,  may_be_uninitialized);
bool my_is_digit(s64 c);
s64 parse_number(char* s, s64 cursor);
bool print_to_builder(String_Builder* builder, char* format_string, Any* args);
void print_sequence_to_builder(String_Builder* builder, Any* args);
void print_bytes(void* a, s64 length,  format_string);
char* get_full_sized_string(Any any);
bool check_null_formatter(Formatter format, String_Builder* builder);
s64 my_c_style_strlen(u8* x);
f64 ceil(f64 x);
f64 floor(f64 x);
f32 ceil(f32 f);
f32 floor(f32 f);
f32 sin(f32 x);
f32 cos(f32 x);
f64 sin(f64 x);
f64 cos(f64 x);
f64 atan(f64 x);
f32 atan(f32 y);
f32 atan2(f32 y, f32 x);
f64 atan2(f64 y, f64 x);
f64 polynomial_eval(f64 x, f64* coef, s32 N);
f64 polynomial_eval_coscof5(f64 x);
f64 polynomial_eval_sincof5(f64 x);
f64 polynomial_eval_1(f64 x, f64* coef, s32 N);
u64 signbit(f64 x);
f64 frexp(f64 x);
f64 ldexp(f64 x, s32 pw2);
f64 sqrt(f64 x);
f64 log(f64 x);
f64 tan(f64 x);
f64 cot(f64 x);
f64 asin(f64 x);
f64 acos(f64 x);
f64 exp(f64 x);
f64 pow(f64 x, f64 y);
f64 reduc(f64 x);
Vector4 row(Matrix4 m, s64 i);
Vector4 column(Matrix4 m, s64 i);
Vector4 multiply(Matrix4 m, Vector4 v);
Vector3 multiply(Matrix4x3 m, Vector4 v);
Vector2 multiply(Matrix2 m, Vector2 v);
Vector4 *(Matrix4 m, Vector4 v);
Vector3 *(Matrix4x3 m, Vector4 v);
Vector3 *(Matrix3 m, Vector3 v);
Matrix2 multiply(Matrix2 m, Matrix2 n);
Matrix3 multiply(Matrix3 m, Matrix3 n);
Matrix4 multiply(Matrix4 m, Matrix3 n);
Matrix4 multiply(Matrix4 m, Matrix4 n);
Matrix4x3 multiply(Matrix4x3 m, Matrix4x3 n);
Matrix4 multiply(Matrix4 m, Matrix4x3 n);
Matrix4 multiply(Matrix4x3 m, Matrix4 n);
Matrix4 *(Matrix4 a, Matrix4 b);
Matrix4x3 *(Matrix4x3 a, Matrix4x3 b);
Matrix4 *(Matrix4 a, Matrix4x3 b);
Matrix4 *(Matrix4x3 a, Matrix4 b);
Matrix4 *(Matrix4 a, Matrix3 b);
Matrix3 *(Matrix3 a, Matrix3 b);
Matrix2 *(Matrix2 a, Matrix2 b);
Vector2 *(Matrix2 a, Vector2 b);
Matrix4 transpose(Matrix4 m);
Matrix3 transpose(Matrix3 m);
void transpose(Matrix4* m);
void transpose(Matrix3* m);
Matrix4 make_scale_matrix4(Vector3 v);
Matrix4 make_translation_matrix4(Vector3 v);
Matrix4 translate(Matrix4 m, Vector3 t);
void translate(Matrix4* m, Vector3 t);
Matrix3 rotate(Matrix3 m, Quaternion q);
Matrix4 rotate(Matrix4 m, Quaternion q);
Matrix4 orthographic_projection_matrix(f32 left, f32 right, f32 bottom, f32 top, f32 near, f32 far,  depth_range_01);
Matrix4 make_projection_matrix(f32 fov_vertical, f32 aspect_ratio_horizontal_over_vertical, f32 z_near, f32 z_far,  x_offset,  y_offset,  depth_range_01);
Matrix4 make_frustum_matrix(f32 l, f32 r, f32 b, f32 t, f32 n, f32 f,  depth_range_01);
Matrix3 lerp(Matrix3 a, Matrix3 b, f32 t);
bool inverse(Matrix3 a,  epsilon);
bool inverse(Matrix4 m);
bool inverse_gaussian_elimination(Matrix4 m);
bool inverse_lengyel(Matrix4 m,  epsilon);
Matrix4 adjugate_lengyel(Matrix4 m);
f32 determinant(Matrix4 m);
Matrix4 isometry_inverse(Matrix4 m);
Matrix3 adjoint_transpose(Matrix3 m);
f32 mat_norm(Matrix3 M, bool tpose);
Vector3 make_reflector(Vector3 v);
void reflect_cols(Matrix3* M, Vector3 u);
void reflect_rows(Matrix3* M, Vector3 u);
Matrix3 polar_decomp(Matrix3 M);
void test_unsigned_division( random_iterations, void random_get);
u64 unsigned_divide_with_remainder_128_64_x64(U128 a, u64 d);
s32 WriteFile(void* handle, void* buffer, u32 buffer_length, u32* written_result, void* overlapped);
void* GetStdHandle(s32 handle);
void EnterCriticalSection(CRITICAL_SECTION_stub* lpCriticalSection);
void LeaveCriticalSection(CRITICAL_SECTION_stub* lpCriticalSection);
void sleep_milliseconds(s32 milliseconds);
bool set_working_directory(char* s);
char* get_working_directory();
void exit(s32 status);
void Sleep(s32 milliseconds);
s32 QueryPerformanceFrequency(s64* result);
s32 QueryPerformanceCounter(s64* result);
DWORD GetCurrentDirectoryW(DWORD nBufferLength, u16* lpBuffer);
void GetLocalTime(SYSTEMTIME* time);
void GetSystemTime(SYSTEMTIME* time);
void ExitProcess(u32 exit_code);
u32 sdbm_hash(void* data, s64 size,  h);
u32 sdbm_float_hash(f32* f, s64 count,  h);
u32 djb2_hash(char* s);
u64 fnv1a_hash(u64 val,  h);
u64 fnv1a_hash(void* data, s64 size,  h);
u64 knuth_hash(u64 x);
u32 get_hash(char* s,  h);
Workspace compiler_create_workspace( name);
void compiler_destroy_workspace(Workspace w);
void compiler_end_intercept(Workspace w);
Message* compiler_wait_for_message();
void compiler_modify_procedure(Workspace w, Code_Procedure_Body* body);
void compiler_make_procedure_live(Workspace w, Code_Procedure_Header* header);
void compiler_custom_link_command_is_complete(Workspace w);
Source_Code_Location compiler_get_struct_location(Workspace w, Type_Info_Struct* info);
char* compiler_get_version_info(Version_Info* version_info_return);
void compiler_report_errors_for_unresolved_identifiers(char* filename, Workspace w);
void compiler_report_errors_for_untyped_declarations_with_these_notes(Workspace w, char** labels);
void compiler_set_memory_breakpoint(void* pointer);
void compiler_add_library_search_directory(char* path);
Code_Node* compiler_get_nodes(Code code);
Code compiler_get_code(Code_Node* node, Code code_to_copy_scope_from);
Runtime_Info get_runtime_info(Workspace w);
Type_Info** get_type_table(Workspace w);
Type get_type(Type_Info* ti);
void add_build_file(char* filename, Workspace w,  loc);
void add_build_string(char* data, Workspace w,  code,  loc);
void add_build_string(char* data, Workspace w, Message* message,  loc);
Build_Options get_build_options(Workspace w);
void set_build_options(Build_Options options, Workspace w,  loc);
void remap_import(Workspace w, char* host_module_name, char* import_name, char* replacement_name);
void set_build_options_dc(Build_Options_During_Compile options, Workspace w);
char* get_name(Workspace w);
Code_Literal* make_integer_literal(s64 v);
Code_Literal* make_string_literal(char* s);
bool is_subclass_of(Type_Info* info, char* base_name,  first_call);
Source_Code_Location make_location(Code_Node* c);
char* get_basename_and_path(char* input_name);
char* get_filename(Code_Node* node);
void copy_commonly_propagated_fields(Build_Options a, Build_Options* b);
void developer_debug(void* x);
char** get_toplevel_command_line();
char* compiler_get_base_path();
void assert(bool arg,  loc);
void* allocator_proc(Allocator_Mode mode, s64 requested_size, s64 old_size, void* old_memory, void* allocator_data);
bool initialize_if_needed();
void finalize();
void unsafe_reset();
s32 atomic_inc(s32* dest);
s32 atomic_dec(s32* dest);
void* _mmap(s64 size, s64* offset);
void unmap(void* address, s64 size, s64 offset, s64 release);
Span* global_get_reserved_spans(s64 span_count);
void global_set_reserved_spans(Span* master, Span* reserve, s64 reserve_span_count);
void span_double_link_list_add(Span** head, Span* span);
void span_double_link_list_pop_head(Span** head, Span* span);
void span_double_link_list_remove(Span** head, Span* span);
void span_mark_as_subspan_unless_master(Span* master, Span* subspan, s64 span_count);
Span* span_map_from_reserve(Heap* heap, s64 span_count);
s64 span_align_count(s64 span_count);
void span_initialize(Span* span, s64 total_span_count, s64 span_count, s64 align_offset);
Span* span_map_aligned_count(Heap* heap, s64 span_count);
Span* span_map(Heap* heap, s64 span_count);
void span_unmap(Span* span);
void span_release_to_cache(Heap* heap, Span* span);
u32 free_list_partial_init(void** list, void** first_block, void* page_start, void* block_start, u32 block_count, u32 block_size);
void* span_initialize_new(Heap* heap, Heap_Size_Class* heap_size_class, Span* span, u32 class_idx);
void span_extract_free_list_deferred(Span* span);
bool span_is_fully_utilized(Span* span);
bool span_finalize(Heap* heap, s64 iclass, Span* span, Span** list_head);
void heap_set_reserved_spans(Heap* heap, Span* master, Span* reserve, s64 reserve_span_count);
void heap_cache_adopt_deferred(Heap* heap, Span** single_span);
void heap_unmap(Heap* heap);
void heap_global_finalize(Heap* heap);
void heap_cache_insert(Heap* heap, Span* span);
Span* heap_thread_cache_deferred_extract(Heap* heap, s64 span_count);
Span* heap_reserved_extract(Heap* heap, s64 span_count);
Span* heap_extract_new_span(Heap* heap, Heap_Size_Class* heap_size_class, s64 span_count, u32 class_idx);
void heap_initialize(Heap* heap);
void heap_orphan(Heap* heap);
Heap* heap_allocate_new();
Heap* heap_extract_orphan(Heap** heap_list);
Heap* heap_allocate();
void _heap_release(void* heapptr);
void heap_finalize(Heap* heap);
void* free_list_pop(void** list);
void* allocate_from_heap_fallback(Heap* heap, Heap_Size_Class* heap_size_class, u32 class_idx);
void* allocate_small(Heap* heap, s64 size);
void* allocate_medium(Heap* heap, s64 size);
void* allocate_large(Heap* heap, s64 size);
void* allocate_huge(Heap* heap, s64 size);
void* allocate(Heap* heap, s64 size);
void deallocate_direct_small_or_medium(Span* span, void* block);
void deallocate_defer_free_span(Heap* heap, Span* span);
void deallocate_defer_small_or_medium(Span* span, void* block);
void deallocate_small_or_medium(Span* span, void* p);
void deallocate_large(Span* span);
void deallocate_huge(Span* span);
void deallocate(void* p);
void* reallocate(Heap* heap, void* p, s64 size, s64 oldsize);
s64 get_usable_size(void* p);
void adjust_size_class(s64 iclass);
bool _initialize_if_needed(Heap** default_heap);
void _finalize();
Heap* _heap_acquire();
bool is_initialized();
s64 usable_size(void* ptr);
bool is_this_yours(Heap* heap, void* memory);
void heap_free_all(Heap* heap);
Global_Statistics global_statistics();
Heap_Statistics heap_statistics(Heap* heap);
void check_alloc(Allocator allocator, void* memory, s64 size);
void check_free(Allocator allocator, void* memory);
void check_realloc(Allocator allocator, void* old_memory, s64 old_size, void* new_memory, s64 new_size);
void check_create_heap(Allocator a);
void check_destroy_heap(Allocator a);
void print_stack_trace(Stack_Trace_Node* node);
void InitializeCriticalSection(CRITICAL_SECTION_stub* section);
Apollo_Time seconds_to_apollo(s64 m);
Apollo_Time milliseconds_to_apollo(s64 m);
Apollo_Time microseconds_to_apollo(s64 m);
Apollo_Time nanoseconds_to_apollo(s64 m);
s32 compare_apollo_times(Apollo_Time a, Apollo_Time b);
f64 to_float64_seconds(Apollo_Time input);
Apollo_Time to_apollo(f64 seconds);
Apollo_Time current_time_consensus();
Apollo_Time current_time_monotonic();
Calendar_Time to_calendar(Apollo_Time at,  time_zone);
Apollo_Time calendar_to_apollo(Calendar_Time ct);
u16* utf8_to_wide(char* utf8);
char* wide_to_utf8(u16* data, s32 length);
s32 WideCharToMultiByte(u32 CodePage, s32 dwFlags, u16* lpWideCharStr, s32 cchWideChar, u8* lpMultiByteStr, s32 cbMultiByte, u8* lpDefaultChar, s32* lpUsedDefaultChar);
s32 MultiByteToWideChar(u32 CodePage, s32 dwFlags, u8* lpMultiByteStr, s32 cbMultiByte, u16* lpWideCharStr, s32 cchWideChar);
bool ==(GUID a, GUID b);
bool SUCCEEDED(HRESULT hr);
bool FAILED(HRESULT hr);
HWND CreateWindowExA(s32 dwExStyle, u8* lpClassName, u8* lpWindowName, u32 dwStyle, s32 x, s32 y, s32 nWidth, s32 nHeight, HWND hwndParent, HMENU hMenu, HINSTANCE hInstance, void* lpParam);
HWND CreateWindowExW(s32 dwExStyle, u16* lpClassName, u16* lpWindowName, u32 dwStyle, s32 x, s32 y, s32 nWidth, s32 nHeight, HWND hwndParent, HMENU hMenu, HINSTANCE hInstance, void* lpParam);
HBRUSH CreateSolidBrush(u32 color);
s32 GetClientRect(HWND hwnd, RECT* rect);
HWND GetDesktopWindow();
HWND GetForegroundWindow();
s32 GetWindowRect(HWND hwnd, RECT* rect);
s32 SetProcessDPIAware();
s32 ShowWindow(HWND hwnd, s32 nCmdShow);
HWND WindowFromPoint(POINT Point);
s32 GetWindowLongA(HWND hwnd, s32 nIndex);
s32 GetWindowLongW(HWND hwnd, s32 nIndex);
s16 RegisterClassExA(WNDCLASSEXA* lpwcx);
s16 RegisterClassExW(WNDCLASSEXW* lpwcx);
s32 SetWindowLongA(HWND hwnd, s32 nIndex, s32 dwNewLong);
s32 SetWindowLongW(HWND hwnd, s32 nIndex, s32 dwNewLong);
s64 SetWindowLongPtrW(HWND hwnd, s32 nIndex, s64 dwNewLong);
s32 ClientToScreen(HWND hwnd, POINT* lpPoint);
s32 ScreenToClient(HWND hwnd, POINT* p);
HDC GetWindowDC(HWND hwnd);
s32 UpdateWindow(HWND hwnd);
HDC CreateCompatibleDC(HDC hdc);
HDC GetDC(HWND hwnd);
s32 GetDeviceCaps(HDC hdc, s32 index);
s32 GetObjectA(HANDLE h, s32 c, void* pv);
s32 GetObjectW(HANDLE h, s32 c, void* pv);
HANDLE GetStockObject(s32 fnObject);
s32 ReleaseDC(HWND hwnd, HDC hdc);
HGDIOBJ SelectObject(HDC hdc, HGDIOBJ h);
HWND WindowFromDC(HDC dc);
HICON ExtractIconA(HINSTANCE hInst, u8* lpszExeFileName, u32 nIconIndex);
HICON ExtractIconW(HINSTANCE hInst, u16* lpszExeFileName, u32 nIconIndex);
HICON LoadIconA(HINSTANCE hInstance, u8* lpIconName);
HICON LoadIconW(HINSTANCE hInstance, u16* lpIconName);
s32 ClipCursor(RECT* lpRect);
s32 GetCursorPos(POINT* p);
HCURSOR LoadCursorA(HINSTANCE hInstance, u8* lpCursorName);
HCURSOR LoadCursorW(HINSTANCE hInstance, s16* lpCursorName);
void SetCursor(HCURSOR cursor);
s32 ShowCursor(s32 bShow);
s32 DispatchMessageA(MSG* msg);
s32 DispatchMessageW(MSG* msg);
LPARAM GetMessageExtraInfo();
s32 PeekMessageA(MSG* msg, HWND hwnd, u32 wMsgFilterMin, u32 wMsgFilterMax, u32 wRemoveMsg);
s32 PeekMessageW(MSG* msg, HWND hwnd, u32 wMsgFilterMin, u32 wMsgFilterMax, u32 wRemoveMsg);
void PostQuitMessage(s32 index);
s32 TranslateMessage(MSG* msg);
s64 DefWindowProcA(HWND hWnd, u32 Msg, WPARAM wParam, LPARAM lParam);
s64 DefWindowProcW(HWND hWnd, u32 Msg, WPARAM wParam, LPARAM lParam);
HMONITOR MonitorFromPoint(POINT pt, u32 dwFlags);
HMONITOR MonitorFromRect(RECT* lprc, u32 dwFlags);
HMONITOR MonitorFromWindow(HWND hwnd, u32 dwFlags);
HWND GetActiveWindow();
s16 GetAsyncKeyState(s32 nVirtKey);
HWND GetFocus();
s16 GetKeyState(s32 nVirtKey);
HWND SetActiveWindow(HWND hwnd);
HWND SetCapture(HWND hwnd);
u32 GetRawInputData(HRAWINPUT hRawInput, u32 uiCommand, void* pData, u32* pcbSize, u32 cbSizeHeader);
u32 GetRawInputDeviceInfoA(HANDLE hDevice, u32 uiCommand, void* pData, u32* pcbSize);
s32 RegisterRawInputDevices(void* pRawInputDevices, u32 uiNumDevices, u32 cbSize);
s32 ChoosePixelFormat(HDC hdc, PIXELFORMATDESCRIPTOR* ppfd);
s32 DescribePixelFormat(HDC hdc, s32 iPixelFormat, u32 nBytes, PIXELFORMATDESCRIPTOR* ppfd);
s32 GetPixelFormat(HDC hdc);
HGLRC wglCreateContext(HDC hdc);
HGLRC wglCreateLayerContext(HDC hdc, s32 level);
HGLRC wglGetCurrentContext();
HDC wglGetCurrentDC();
void* wglGetProcAddress(u8* lpszProc);
u32 GetSystemDirectoryA(u8* lpBuffer, u32 uSize);
u32 GetSystemDirectoryW(u16* lpBuffer, u32 uSize);
void GetSystemInfo(SYSTEM_INFO* lpSystemInfo);
void GetNativeSystemInfo(SYSTEM_INFO* lpSystemInfo);
u32 GetVersion();
s32 QueryPerformanceFrequency(s64* result);
s32 QueryPerformanceCounter(s64* result);
void RtlGetVersion(OSVERSIONINFOW* lpVersionInfo);
bool HasOverlappedIoCompleted(OVERLAPPED overlapped);
HANDLE CreateNamedPipeW(u16* lpName, u32 dwOpenMode, u32 dwPipeMode, u32 nMaxInstances, u32 nOutBufferSize, u32 nInBufferSize, u32 nDefaultTimeOut, SECURITY_ATTRIBUTES* lpSecurityAttributes);
HANDLE CreateEventA(SECURITY_ATTRIBUTES* lpEventAttributes, s32 bManualReset, s32 bInitialState, u8* lpName);
HANDLE CreateEventW(SECURITY_ATTRIBUTES* lpEventAttributes, s32 bManualReset, s32 bInitialState, u16* lpName);
HANDLE CreateSemaphoreA(SECURITY_ATTRIBUTES* lpSemaphoreAttributes, s32 lInitialCount, s32 lMaximumCount, u8* lpName);
HANDLE CreateSemaphoreW(SECURITY_ATTRIBUTES* lpSemaphoreAttributes, s32 lInitialCount, s32 lMaximumCount, u16* lpName);
void DeleteCriticalSection(CRITICAL_SECTION* lpCriticalSection);
void EnterCriticalSection(CRITICAL_SECTION* lpCriticalSection);
s32 GetOverlappedResult(HANDLE hFile, OVERLAPPED* lpOverlapped, s32* lpNumberOfBytesTransferred, s32 bWait);
void InitializeCriticalSection(CRITICAL_SECTION* lpCriticalSection);
void LeaveCriticalSection(CRITICAL_SECTION* lpCriticalSection);
s32 PulseEvent(HANDLE handle);
DWORD WaitForSingleObject(HANDLE handle, DWORD milliseconds);
void InitializeConditionVariable(CONDITION_VARIABLE* ConditionVariable);
void WakeConditionVariable(CONDITION_VARIABLE* ConditionVariable);
void WakeAllConditionVariable(CONDITION_VARIABLE* ConditionVariable);
HANDLE CreateFileMappingA(HANDLE hFile, SECURITY_ATTRIBUTES* lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName);
HANDLE CreateFileMappingW(HANDLE hFile, SECURITY_ATTRIBUTES* lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, u16* lpName);
HGLOBAL GlobalAlloc(u32 uFlags, SIZE_T dwBytes);
void* GlobalFree(HGLOBAL hMem);
void* GlobalLock(HGLOBAL hMem);
HLOCAL LocalFree(HLOCAL hMem);
void* MapViewOfFile(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap);
void* VirtualAlloc(void* lpAddress, u64 dwSize, u32 flAllocationType, u32 flProtect);
SIZE_T VirtualQuery(void* lpAddress, MEMORY_BASIC_INFORMATION* lpBuffer, SIZE_T dwLength);
s32 CloseHandle(HANDLE handle);
s32 GetModuleFileNameA(HANDLE module, u8* result, s32 size);
s32 GetModuleFileNameW(HANDLE module, u16* result, s32 size);
HANDLE GetModuleHandleA(u8* module_name);
HANDLE GetModuleHandleW(u16* module_name);
s32 CreateDirectoryA(u8* lpPathName, SECURITY_ATTRIBUTES* lpSecurityAttributes);
s32 CreateDirectoryW(u16* lpPathName, SECURITY_ATTRIBUTES* lpSecurityAttributes);
DWORD GetCurrentDirectoryA(DWORD nBufferLength, u8* lpBuffer);
DWORD GetCurrentDirectoryW(DWORD nBufferLength, u16* lpBuffer);
HANDLE GetStdHandle(s32 handle);
LCID GetUserDefaultLCID();
HANDLE GetClipboardData(u32 uFormat);
HANDLE SetClipboardData(u32 uFormat, HANDLE hMem);
HANDLE CreateJobObjectA(SECURITY_ATTRIBUTES* lpSecurityAttributes, u8* name);
s32 GetExitCodeProcess(HANDLE hProcess, u32* lpExitCode);
void ExitProcess(u32 exit_code);
HANDLE GetCurrentProcess();
u32 GetCurrentProcessId();
HANDLE GetCurrentThread();
DWORD GetCurrentThreadId();
DWORD GetProcessId(HANDLE Process);
DWORD GetThreadId(HANDLE Thread);
s32 ResumeThread(HANDLE thread);
s32 SetThreadPriority(HANDLE thread, s32 priority);
void Sleep(s32 milliseconds);
void DebugBreak();
void OutputDebugStringA(u8* s);
void OutputDebugStringW(u16* s);
u32 timeGetDevCaps(TIMECAPS* ptc, u32 cbtc);
u32 timeBeginPeriod(u32 period);
u32 timeEndPeriod(u32 period);
u32 timeGetTime();
u32 timeGetSystemTime(MMTIME* pmmt, u32 cbmmt);
s32 MessageBoxA(HWND hWnd, u8* lpText, u8* lpCaption, u32 uType);
s32 MessageBoxW(HWND hWnd, u16* lpText, u16* lpCaption, u32 uType);
HANDLE CreateFileA(u8* filename, u32 desired_access, u32 share_mode, void* security, u32 creation, u32 flags_and_attributes, HANDLE hTemplateFile);
HANDLE CreateFileW(u16* filename, u32 desired_access, u32 share_mode, void* security, u32 creation, u32 flags_and_attributes, HANDLE hTemplateFile);
HANDLE CreateIoCompletionPort(HANDLE FileHandle, HANDLE ExistingCompletionPort, u64 CompletionKey, u32 NumberOfConcurrentThreads);
HANDLE FindFirstFileA(u8* lpFileName, void* lpFindFileData);
HANDLE FindFirstFileW(u16* lpFileName, WIN32_FIND_DATAW* lpFindFileData);
u32 GetFileAttributesA(u8* lpFileName);
u32 GetFileAttributesW(u16* lpFileName);
u32 GetFileSize(HANDLE file, u32* FileSizeHigh);
s32 GetFileSizeEx(HANDLE file, LARGE_INTEGER* size);
DWORD GetFullPathNameA(u8* filename, DWORD buffer_length, u8* buffer, u8** file_part);
DWORD GetFullPathNameW(u16* filename, DWORD buffer_length, u16* buffer, u16** file_part);
void* SymFunctionTableAccess64(HANDLE hProcess, u64 AddrBase);
u64 SymGetModuleBase64(HANDLE hProcess, u64 dwAddr);
void RtlCaptureContext(CONTEXT* ContextRecord);
s32 FormatMessageA(u32 dwFlags, void* lpSource, u32 dwMessageId, u32 dwLanguageId, u8** lpBuffer, u32 nSize, void* Arguments);
s32 FormatMessageW(u32 dwFlags, void* lpSource, u32 dwMessageId, u32 dwLanguageId, u16** lpBuffer, u32 nSize, void* Arguments);
OS_Error_Code GetLastError();
NTSTATUS RtlGetLastNtStatus();
s32 GetFileTime(HANDLE file, FILETIME* lpCreationTime, FILETIME* lpLastAccessTime, FILETIME* lpLastWriteTime);
void GetLocalTime(SYSTEMTIME* time);
void GetSystemTime(SYSTEMTIME* time);
void GetSystemTimeAsFileTime(FILETIME* lpSystemTimeAsFileTime);
void GetSystemTimePreciseAsFileTime(FILETIME* lpSystemTimeAsFileTime);
s32 PathFileExistsW(u16* pszPath);
s32 GetSystemMetrics(s32 nIndex);
HBITMAP CreateCompatibleBitmap(HDC hdc, s32 cx, s32 cy);
HBITMAP CreateDIBSection(HDC hdc, BITMAPINFO* pbmi, u32 usage, u8** ppvBits, HANDLE hSection, DWORD offset);
s32 GetDIBits(HDC hdc, HBITMAP hbm, u32 start, u32 cLines, void* lpvBits, BITMAPINFO* lpbmi, u32 usage);
u32 CommDlgExtendedError();
void DragFinish(HDROP hDrop);
u32 DragQueryFileW(HDROP hDrop, u32 iFile, u16* lpszFile, u32 cch);
s32 SHFileOperationA(SHFILEOPSTRUCTA* FileOp);
s32 SHFileOperationW(SHFILEOPSTRUCTW* FileOp);
void _endthreadex(u32 return_code);
u8* getenv(u8* var);
s16* _wgetenv(s16* var);
u16 MAKELANGID(u16 usPrimaryLanguage, u16 usSubLanguage);
s32 WideCharToMultiByte(u32 CodePage, s32 dwFlags, u16* lpWideCharStr, s32 cchWideChar, u8* lpMultiByteStr, s32 cbMultiByte, u8* lpDefaultChar, s32* lpUsedDefaultChar);
s32 MultiByteToWideChar(u32 CodePage, s32 dwFlags, u8* lpMultiByteStr, s32 cbMultiByte, u16* lpWideCharStr, s32 cchWideChar);
HRESULT IUnknown_QueryInterface(IUnknown* this, IID* riid, void** ppvObject);
u32 IUnknown_AddRef(IUnknown* this);
u32 IUnknown_Release(IUnknown* this);
IUnknown_VTable* vtable(IUnknown* obj);
void safe_release(IUnknown* obj);
void safe_release_and_reset(IUnknown** b);
GUID uid(char* str);
f32 mat_norm(Matrix3 M);
f32 mat_norm(Matrix3 M);
FormatFloat formatFloat(Any value,  width,  trailing_width,  mode,  zero_removal);
BOOL SetCurrentDirectoryW(u16* name);
BOOL FlushFileBuffers(HANDLE hFile);
char* operator_to_string(Operator_Type op);
void compiler_begin_intercept(Workspace w, Intercept_Flags flags);
void compiler_report(char* message,  loc,  mode);
void compiler_report(char* filename, s64 line_number, s64 character_number, char* error_text,  mode);
void compiler_set_workspace_status(Workspace_Status status, Workspace w);
Get_Root_Type_Status get_root_type(Code code);
void compiler_set_type_info_flags(Type type, Type_Info_Flags flags);
void provide_import(Workspace w, Message_Failed_Import* message, Provided_Import_Type type, char* value);
u8* add_global_data(u8* data, Data_Segment_Index segment, Data_Segment* user_segment, Workspace w);
Data_Segment* add_data_segment(char* section_name,  characteristics, s32 alignment, Workspace w);
void set_optimization(Build_Options* build_options, Optimization_Type type,  preserve_debug_info);
void unmap_os(void* address, s64 size, s64 release);
void* mmap_os(s64 size, s64* offset);
void spin();
s32 atomic_load(s32* src);
void* atomic_load(void** src);
void atomic_store(s32* dest, s32 value);
void atomic_store(void** dest, void* value);
s32 atomic_add(s32* dest, s32 value);
void* atomic_exchange(void** dest, void* value);
void* VirtualAlloc(void* lpAddress, u64 dwSize, u32 flAllocationType, u32 flProtect);
s32 VirtualFree(void* lpAddress, u64 dwSize, u32 dwFreeType);
void GetSystemInfo(SYSTEM_INFO* lpSystemInfo);
bool compare_and_swap(T* pointer, T old, T new);
f32 Sign(f32 x);
Vector3 *(Quaternion q, Vector3 v);
Vector3 *(Matrix4 m, Vector3 v);
Quaternion make_quaternion_from_axis_and_angle(Vector3 axiss, f32 theta);
Allocator create_heap(Allocator a);
void destroy_heap(Allocator b);
Allocator_Caps get_capabilities(Allocator b);
Type_Info_Struct_Member* get_field(Type_Info_Struct* info, char* name);
bool IsScalar(Type T);
s64 enum_range_given_info(Type_Info_Enum* info);
void* temporary_allocator_proc(Allocator_Mode mode, s64 requested_size, s64 old_size, void* old_memory, void* allocator_data);
void free_pages_down_to(Temporary_Storage* ts, void* page);
bool add_new_page(Temporary_Storage* ts, s64 minimum_size);
Stack_Trace_Node* pack_stack_trace();
Stack_Trace_Node* pack_stack_trace(Stack_Trace_Node* node);
void print_stack_trace(Stack_Trace_Node* node, char* prefix,  to_standard_error);
void log_stack_trace(Stack_Trace_Node* node,  log_flags,  prefix);
char* get_stack_trace_string(Stack_Trace_Node* node);
void array_reserve(Resizable_Array* array, s64 desired_items, s64 element_size);
void maybe_grow(Resizable_Array* array, s64 element_size);
void log(char* format_string, Any* args,  loc,  flags, u32 user_flags, Log_Section* section);
void log(Log_Section* section, char* format_string, Any* args,  loc,  flags, u32 user_flags);
void log_error(char* format_string, Any* args,  loc,  flags, u32 user_flags, Log_Section* section);
void log_error(Log_Section* section, char* format_string, Any* args,  loc,  flags, u32 user_flags);
void append_struct_info(String_Builder* builder, Type_Info_Struct* info, void* base_pointer, FormatStruct* format);
void print_type_to_builder(String_Builder* builder, Type_Info* info,  print_parameters_matching_defaults);
Type_Info_Struct_Member* isFormatter(Type_Info_Struct* info);
void print_array(String_Builder* builder, Any any, Type_Info_Array* info_array, FormatArray format,  may_be_uninitialized);
char* type_to_string(Type_Info* info);
bool param_matches_default(Type_Info_Struct* info, Type_Info_Struct_Member* param);
void __jai_runtime_fini(void* _context);
Memcpy_Map* find_or_create_memcpy_map(Type_Info_Struct* foreign_type);
void maybe_remap_one_member(Type_Info_Struct_Member* our_member, Type_Info_Struct* foreign_type, Type_Info_Struct* our_type, Memcpy_Map* map);
bool print_matrix(String_Builder* builder, Any any, void* user_data);
bool math_struct_printer(String_Builder* builder, Any any, void* user_data);
BOOL AdjustWindowRect(RECT* lpRect, u32 dwStyle, BOOL bMenu);
BOOL AdjustWindowRectEx(RECT* lpRect, DWORD dwStyle, BOOL bMenu, DWORD dwExStyle);
BOOL DestroyWindow(HWND hWnd);
BOOL SetWindowPos(HWND hwnd, HWND hWndInsertAfter, s32 X, s32 Y, s32 cx, s32 cy, u32 uFlags);
BOOL SetWindowTextA(HWND hWnd, u8* lpString);
BOOL SetWindowTextW(HWND hWnd, u16* lpString);
BOOL UnregisterClassA(LPCSTR lpClassName, HINSTANCE hInstance);
BOOL UnregisterClassW(LPCWSTR lpClassName, HINSTANCE hInstance);
BOOL ValidateRect(HWND hwnd, RECT* lpRect);
BOOL DeleteDC(HDC hdc);
BOOL DeleteObject(HGDIOBJ ho);
BOOL PrintWindow(HWND hwnd, HDC hdcBlt, u32 nFlags);
BOOL DrawIconEx(HDC hdc, s64 xLeft, s64 yTop, HICON hIcon, s64 cxWidth, s64 cyWidth, u32 istepIfAniCur, HBRUSH hbrFlickerFreeDraw, u32 diFlags);
BOOL GetIconInfo(HICON hIcon, ICONINFO* piconinfo);
BOOL GetIconInfoExA(HICON hIcon, void* piconinfo);
BOOL GetIconInfoExW(HICON hIcon, ICONINFOEXW* piconinfo);
BOOL GetCursorInfo(CURSORINFO* info);
BOOL GetMonitorInfoA(HMONITOR hMonitor, MONITORINFO* lpmi);
BOOL GetMonitorInfoW(HMONITOR hMonitor, MONITORINFO* lpmi);
BOOL ReleaseCapture();
BOOL SetPixelFormat(HDC hdc, s32 iPixelFormat, PIXELFORMATDESCRIPTOR* ppfd);
BOOL SwapBuffers(HDC hdc);
BOOL wglCopyContext(HGLRC hglrcSrc, HGLRC hglrcDst, u32 mask);
BOOL wglDeleteContext(HGLRC oldContext);
BOOL wglMakeCurrent(HDC hdc, HGLRC newContext);
BOOL wglRealizeLayerPalette(HDC hdc, s32 iLayerPlane, BOOL bRealize);
BOOL wglShareLists(HGLRC hrcSrvShare, HGLRC hrcSrvSource);
BOOL wglSwapLayerBuffers(HDC hdc, u32 fuFlags);
BOOL wglUseFontBitmapsA(HDC hDC, u32 first, u32 count, u32 listBase);
BOOL wglUseFontBitmapsW(HDC hDC, u32 first, u32 count, u32 listBase);
BOOL GetComputerNameA(u8* lpBuffer, u32* nSize);
BOOL GetComputerNameW(u16* lpBuffer, u32* nSize);
BOOL GetUserNameA(u8* lpBuffer, u32* lpnSize);
BOOL GetUserNameW(u16* lpBuffer, u32* lpnSize);
BOOL CryptAcquireContextA(HCRYPTPROV* phProv, LPCSTR szContainer, LPCSTR szProvider, DWORD dwProvType, DWORD dwFlags);
BOOL CryptGenRandom(HCRYPTPROV phProv, DWORD dwLen, u8* pbBuffer);
BOOL CryptReleaseContext(HCRYPTPROV phProv, DWORD dwFlags);
BOOL GetVersionExA(OSVERSIONINFOA* lpVersionInfo);
BOOL GetVersionExW(OSVERSIONINFOW* lpVersionInfo);
BOOL CreatePipe(HANDLE* hReadPipe, HANDLE* hWritePipe, SECURITY_ATTRIBUTES* lpPipeAttributes, DWORD nSize);
BOOL SetNamedPipeHandleState(HANDLE hNamedPipe, DWORD* lpMode, DWORD* lpMaxConnectionCount, DWORD* lpCollectDataTimeout);
BOOL PeekNamedPipe(HANDLE hNamedPipe, void* lpBuffer, DWORD nBufferSize, DWORD* lpByesRead, DWORD* lpTotalBytesAvail, u32* lpBytesLeftThisMessage);
BOOL ConnectNamedPipe(HANDLE hNamedPipe, OVERLAPPED* lpOverlapped);
HANDLE CreateWaitableTimerW(SECURITY_ATTRIBUTES* lpTimerAttributes, BOOL bManualReset, u16* lpTimerName);
BOOL ReleaseSemaphore(HANDLE hSemaphore, s32 lReleaseCount, s32* lpPreviousCount);
BOOL SetWaitableTimer(HANDLE hTimer, LARGE_INTEGER* lpDueTime, s32 lPeriod, void* pfnCompletionRoutine, void* lpArgToCompeltionRoutine, BOOL fResume);
DWORD WaitForMultipleObjects(DWORD nCount, HANDLE* lpHandles, BOOL bWaitAll, DWORD dwMilliseconds);
BOOL SleepConditionVariableCS(CONDITION_VARIABLE* ConditionVariable, CRITICAL_SECTION* CriticalSection, DWORD dwMilliseconds);
BOOL SleepConditionVariableSRW(CONDITION_VARIABLE* ConditionVariable, void* SRWLock, DWORD dwMilliseconds, u32 Flags);
BOOL GlobalMemoryStatusEx(MEMORYSTATUSEX* lpBuffer);
BOOL GlobalUnlock(HGLOBAL hMem);
HANDLE OpenFileMappingA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName);
HANDLE OpenFileMappingW(DWORD dwDesiredAccess, BOOL bInheritHandle, u16* lpName);
BOOL UnmapViewOfFile(void* address);
BOOL VirtualFree(void* lpAddress, u64 dwSize, u32 dwFreeType);
BOOL VirtualLock(void* lpAddress, u64 dwSize);
BOOL VirtualProtect(void* lpAddress, u64 dwSize, u32 flNewProtect, u32* lpflOldProtect);
BOOL SetHandleInformation(HANDLE hObject, DWORD dwMask, DWORD dwFlags);
BOOL ReadDirectoryChangesW(HANDLE hDirectory, void* lpBuffer, s32 nBufferLength, s32 bWatchSubtree, s32 dwNotifyFilter, s32* lpBytesReturned, OVERLAPPED* lpOverlapped, void* lpCompletionRoutine);
BOOL RemoveDirectoryA(u8* lpPathName);
BOOL RemoveDirectoryW(u16* lpPathName);
BOOL SetCurrentDirectoryW(u16* name);
BOOL GetConsoleScreenBufferInfo(HANDLE hConsoleOutput, CONSOLE_SCREEN_BUFFER_INFO* lpConsoleScreenBufferInfo);
BOOL SetConsoleTextAttribute(HANDLE hConsoleOutput, u16 wAttributes);
BOOL GetConsoleMode(HANDLE hConsoleHandle, DWORD* lpMode);
BOOL SetConsoleMode(HANDLE hConsoleHandle, DWORD lpMode);
BOOL SetConsoleCP(u32 wCodePageID);
BOOL SetConsoleOutputCP(u32 wCodePageID);
BOOL CloseClipboard();
BOOL EmptyClipboard();
BOOL OpenClipboard(HWND hwnd);
BOOL AssignProcessToJobObject(HANDLE hJob, HANDLE hProcess);
BOOL CreateProcessA(u8* lpApplicationName, u8* lpCommandLine, SECURITY_ATTRIBUTES* lpSecurityAttributes, SECURITY_ATTRIBUTES* lpThreadAttributes, BOOL bInheritHandles, Creation_Flags dwCreationFlags, void* lpEnvironment, u8* lpCurrentDirectory, STARTUPINFOA* lpStartupInfo, PROCESS_INFORMATION* lpProcessInformation);
BOOL CreateProcessW(u16* lpApplicationName, u16* lpCommandLine, SECURITY_ATTRIBUTES* lpSecurityAttributes, SECURITY_ATTRIBUTES* lpThreadAttributes, BOOL bInheritHandles, Creation_Flags dwCreationFlags, void* lpEnvironment, u16* lpCurrentDirectory, STARTUPINFOW* lpStartupInfo, PROCESS_INFORMATION* lpProcessInformation);
BOOL GetProcessWorkingSetSize(HANDLE hProcess, SIZE_T* lpMinimumWorkingSetSize, SIZE_T* lpMaximumWorkingSetSize);
HANDLE OpenThread(u32 dwDesiredAccess, BOOL bInheritHandle, u32 dwThreadId);
BOOL SuspendThread(HANDLE hThread);
BOOL TerminateProcess(HANDLE hProcess, u32 uExitCode);
BOOL DebugActiveProcess(u32 dwProcessId);
BOOL GetThreadContext(HANDLE hThread, CONTEXT* lpContext);
BOOL IsDebuggerPresent();
BOOL CancelIo(HANDLE hFile);
BOOL CopyFileW(u16* lpFileName, u16* lpNewFileName, BOOL bFailIfExists);
BOOL CopyFileA(u8* lpFileName, u8* lpNewFileName, BOOL bFailIfExists);
BOOL CreateHardLinkA(u8* lpFileName, u8* lpExistingFileName, SECURITY_ATTRIBUTES* lpSecurityAttributes);
BOOL CreateHardLinkW(u16* lpFileName, u16* lpExistingFileName, SECURITY_ATTRIBUTES* lpSecurityAttributes);
BOOL DeleteFileA(u8* filename);
BOOL DeleteFileW(u16* filename);
BOOL FindClose(HANDLE file);
BOOL FindNextFileA(HANDLE hFile, void* lpFindFileData);
BOOL FindNextFileW(HANDLE hFile, WIN32_FIND_DATAW* lpFindFileData);
BOOL FlushFileBuffers(HANDLE hFile);
BOOL GetQueuedCompletionStatus(HANDLE CompletionPort, u32* NumberOfBytesTransferred, u64* CompletionKey, OVERLAPPED** Overlapped, u32 Milliseconds);
BOOL LockFile(HANDLE file, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh);
BOOL LockFileEx(HANDLE file, DWORD dwFlags, DWORD dwReserved, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh, OVERLAPPED* lpOverlapped);
BOOL MoveFileA(u8* filename, u8* new_filename);
BOOL MoveFileW(u16* filename, u16* new_filename);
BOOL ReadFile(HANDLE file, void* buffer, DWORD to_read, DWORD* did_read, void* overlapped);
BOOL ReplaceFileW(LPCWSTR lpReplacedFileName, LPCWSTR lpReplacementFileName, LPCWSTR lpBackupFileName, DWORD dwReplaceFlags, void* lpExclude, void* lpReserved);
BOOL WriteFile(HANDLE handle, void* buffer, DWORD buffer_length, DWORD* written_result, void* overlapped);
HRESULT DwmIsCompositionEnabled(BOOL* pfEnabled);
BOOL SymCleanup(HANDLE hProcess);
BOOL SymFromAddr(HANDLE hProcess, u64 Address, u64* Displacement, SYMBOL_INFO* Symbol);
BOOL SymGetLineFromAddr64(HANDLE hProcess, u64 dwAddr, u32* pdwDisplacement, IMAGEHLP_LINE64* Line);
BOOL SymGetSymFromAddr64(HANDLE hProcess, u64 Address, u64* Displacement, IMAGEHLP_SYMBOL64* Symbol);
BOOL SymInitialize(HANDLE hProcess, u8* UserSearchPath, BOOL fInvadeProcess);
BOOL FlashWindow(HWND hWnd, BOOL bInvert);
BOOL FlashWindowEx(FLASHWINFO* pfwi);
BOOL FileTimeToLocalFileTime(FILETIME* lpFileTime, FILETIME* lpLocalFileTime);
BOOL LocalFileTimeToFileTime(FILETIME* lpLocalFileTime, FILETIME* lpFileTime);
BOOL FileTimeToSystemTime(FILETIME* lpFileTime, SYSTEMTIME* lpSystemTime);
BOOL SystemTimeToFileTime(SYSTEMTIME* lpSystemTime, FILETIME* lpFileTime);
BOOL SystemTimeToTzSpecificLocalTime(TIME_ZONE_INFORMATION* lpTimeZone, SYSTEMTIME* lpUniversalTime, SYSTEMTIME* lpLocalTime);
BOOL SystemParametersInfoA(u32 uiAction, u32 uiParam, void* pvParam, u32 fWinIni);
BOOL SystemParametersInfoW(u32 uiAction, u32 uiParam, void* pvParam, u32 fWinIni);
void DragAcceptFiles(HWND hWnd, BOOL fAccept);
BOOL FreeLibrary(HMODULE module);
void* GetProcAddress(HMODULE module, u8* proc_name);
HMODULE LoadLibraryA(u8* filename);
HMODULE LoadLibraryW(u16* filename);
HMODULE LoadLibraryExA(u8* filename, HANDLE file, DWORD flags);
HMODULE LoadLibraryExW(u16* filename, HANDLE file, DWORD flags);
BOOL GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP RelationshipType, SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX* Buffer, u32* ReturnedLength);
HANDLE CreateThread(void* threadAttributes, s64 stackSize, void* startAddress, void* parameter, Creation_Flags creation_flags, s32* threadIdReturn);
u32* _beginthreadex(void* _Security, u32 _StackSize, void* _StartAddress, void* _ArgList, Creation_Flags _InitFlag, s32* _ThrdAddr);
BOOL SetInformationJobObject(HANDLE hJob, JOBOBJECTINFOCLASS JobOjectInformationClass, void* lpJobObjectInformation, u32 cbJobObjectInformationLength);
u32 SetFilePointer(HANDLE hFile, s32 liDistanceToMove, s32* lpNewFilePointer, SetFilePointer_MoveMethod dwMoveMethod);
BOOL SetFilePointerEx(HANDLE hFile, LARGE_INTEGER_S64 liDistanceToMove, LARGE_INTEGER_S64* lpNewFilePointer, SetFilePointer_MoveMethod dwMoveMethod);
HANDLE FindFirstFileExA(u8* lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, void* lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, void* lpSearchFilter, DWORD dwAdditionalFlags);
HANDLE FindFirstFileExW(u16* lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, void* lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, void* lpSearchFilter, DWORD dwAdditionalFlags);
BOOL GetFileInformationByHandleEx(HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, void* lpFileInformation, u32 dwBufferSize);
BOOL SetFileInformationByHandle(HANDLE File, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, void* FileInformation, u32 BufferSize);
SYMOPT SymSetOptions(SYMOPT SymOptions);
BOOL MiniDumpWriteDump(HANDLE hProcess, DWORD ProcessId, HANDLE hFile, MINIDUMP_TYPE DumpType, MINIDUMP_EXCEPTION_INFORMATION* ExceptionParam, MINIDUMP_USER_STREAM_INFORMATION* UserStreamParam, MINIDUMP_CALLBACK_INFORMATION* CallbackParam);
LPTOP_LEVEL_EXCEPTION_FILTER SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
SEM GetErrorMode();
SEM SetErrorMode(SEM uMode);
BOOL BitBlt(HDC hdc, s32 x, s32 y, s32 cx, s32 cy, HDC hdcSrc, s32 x1, s32 y1, ROP rop);
BOOL StretchBlt(HDC hdcDest, s32 xDest, s32 yDest, s32 wDest, s32 hDest, HDC hdcSrc, s32 xSrc, s32 ySrc, s32 wSrc, s32 hSrc, ROP rop);
s32 SetStretchBltMode(HDC hdc, BLTMODE mode);
BOOL GetOpenFileNameA(OPENFILENAMEA* arg);
BOOL GetSaveFileNameA(OPENFILENAMEA* arg);
BOOL GetOpenFileNameW(OPENFILENAMEW* arg);
BOOL GetSaveFileNameW(OPENFILENAMEW* arg);
Complex *(Complex a, Complex b);
void assert(bool truth, char* message,  location);
bool compare_function(Key_Type a, Key_Type b);
BOOL EnumDisplayMonitors(HDC hdc, RECT* lprcClip, MONITORENUMPROC lpfnEnum, LPARAM dwData);
BOOL StackWalk64(IMAGE_FILE_MACHINE MachineType, HANDLE hProcess, HANDLE hThread, STACKFRAME64* StackFrame, void* ContextRecord, ReadProcessMemoryProc64 ReadMemoryRoutine, FunctionTableAccessProc64 FunctionTableAccessRoutine, GetModuleBaseProc64 GetModuleBaseRoutine, TranslateAddressProc64 TranslateAddres);
BOOL AddSecureMemoryCacheCallback(PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack);
bool is_in_span(void* memory, Span* span);
Apollo_Time filetime_to_apollo(FILETIME ft);
FILETIME to_filetime(Apollo_Time at);
bool compare_function(Key_Type a, Key_Type b);
void* __jai_runtime_init(s32 argc, u8** argv);
void remap_context();
void remap_context(void* foreign_context, Type_Info_Struct* foreign_type);
u32 hex(s64 c);
bool compare_and_swap(T* pointer, T old, T new);
T* New();
T* New();
void copy_repeated_character(u8* destination, s64 count);
T max(T a, T b);
T min(T a, T b);
s64 append_repeated_character(String_Builder* builder, s64 count);
void copy_repeated_character(u8* destination, s64 count);
s64 append_repeated_character(String_Builder* builder, s64 count);
u64 get_hash(Source_Code_Location loc, s64 identifier);
T* NewArray(s64 count, s32 alignment);
T rotation_matrix(Quaternion q);
Quaternion get_rotation(T m);
T normalize(T v,  epsilon,  fallback);
void* find_and_occupy_empty_slot(void array);
T normalize(T v,  epsilon,  fallback);
Quaternion get_small_angle_rotation_to_delta_quaternion_scaled(Vector3 delta_angular, Quaternion orientation);
void push_grid(Vector3 plane_origin, Vector3 plane_normal, s64 min_for, s64 max_for, f32 density,  color);
void push_vector(Vector3 start, Vector3 end, Vector4 color);
void push_line(Vector3 start, Vector3 end, Vector4 color);
T clamp(T x, T a, T b);
void reflect_results_callback(Body* body);
f32 normalize(T* v,  epsilon,  fallback);
void* add_bucket(void array);
f32 normalize(T* v,  epsilon,  fallback);
void array_add(T** array, T item);
void* find_or_add(void table, void key);
T min(T a, T b);
Vector3 multiply(T m, Vector3 v);
f64 sin_or_cos(f64 x);
f64 sin_or_cos(f64 x);
T* New();
s64 array_unordered_remove_by_value(T** array, T item);
void* table_find_pointer(void table, void key);
void* table_find_pointer(void table, void key);
f64 polynomial(f64 x);
T max(T a, T b);
void array_add(T** array, T item);
bool table_remove(void table, void key);
T* peek_pointer(T* array);
void remember_allocators(T* data);
void* bucket_array_find_pointer(void array, Bucket_Locator locator);
void* table_add(void table, void key, void value);
f64 polynomial(f64 x);
void bucket_array_remove(void array, Bucket_Locator locator);
void array_add(T** array, T item);
u32 get_hash(T x,  h);
u32 get_hash(T x,  h);
void* table_set(void table, void key, void value);
f64 polynomial(f64 x);
void* bucket_array_find_pointer(void array, Bucket_Locator locator);
void* find_and_occupy_empty_slot(void array);
bool array_find(T* array, T item);
void hash_function(quick_lambda_parameter_4ec17590 x);
void hash_function(quick_lambda_parameter_4ec17590 x);
void* table_add(void table, void key, void value);
f64 polynomial(f64 x);
void* add_bucket(void array);
void bucket_array_remove(void array, Bucket_Locator locator);
T* New();
s64 array_unordered_remove_by_value(T** array, T item);
bool array_find(T* array, T item);
void array_add(T** array, T item);
bool is_valid(T a);
void clamp_length(T* v, f32 max);
void expand(void table);
void _internal_resize_memory(void table, s64 slots_to_allocate);
T* NewArray(s64 count, s32 alignment);
void expand(void table);
void _internal_resize_memory(void table, s64 slots_to_allocate);
T* NewArray(s64 count, s32 alignment);

#endif // GENERATED_TRANSPILED_HPP
